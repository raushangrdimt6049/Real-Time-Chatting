<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Chat</title>
    <!-- Add a link to your favicon -->
    <link rel="icon" href="https://i.pinimg.com/474x/f7/2a/b4/f72ab43202047860f3dace2bd2728502.jpg" type="image/x-icon">
    <style>
        /* --- Google Font --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        /* --- Base Styles & Body --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --bg-gradient-start: #09203f;
            --bg-gradient-end: #537895;
            --chat-bg-gradient-start: #1d2b3c;
            --chat-bg-gradient-end: #2f4858;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(45deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%); /* Dark blue gradient */
            height: 100vh;
            overflow: hidden; /* Hide scrollbars and keep hearts contained */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.5s ease; /* This transition won't work on gradients, but is good practice */
        }

        /* New class to apply the love theme background when chat is active */
        body.chat-active {
            /* A simple gradient for the chat view */
            background: linear-gradient(45deg, var(--chat-bg-gradient-start) 0%, var(--chat-bg-gradient-end) 100%);
        }

        /* --- Main Chat Container --- */
        .chat-app-container {
            display: flex;
            gap: 40px;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            position: relative; /* Ensure content is above the emojis */
            z-index: 1; /* Make sure chat container is on top of background elements */
            border-radius: 25px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Hide overflowing parts of the slideshow */
        }

        /* --- Background Slideshow --- */
        .background-slideshow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Behind all content */
            background-size: contain; /* Changed from cover to contain */
            background-position: center;
            background-repeat: no-repeat; /* Prevent image from repeating */
            animation: slide 9s infinite;
            background-color: rgba(0, 0, 0, 0.5); /* Fallback for empty space */
        }

@keyframes slide {
    0%, 30%, 100% {
        background-image: url('https://i.pinimg.com/736x/43/22/17/43221748fb4c65699f6e55c485da3f2f.jpg'); /* Army */
        opacity: 1;
    }
    33%, 63% {
        background-image: url('https://i.pinimg.com/474x/7b/e0/6e/7be06eb6e6a0dddda7f24a9758ff7c43.jpg'); /* Navy */
        opacity: 1;
    }
    66%, 97% {
        background-image: url('https://i.pinimg.com/736x/c9/00/0a/c9000a208a964edaa1a128ed71befdea.jpg'); /* Air Force */
        opacity: 1;
    }
}
        

        /* Hide the slideshow when the chat is active */
        body.chat-active .background-slideshow 
        {
            display: none;
        }

        /* --- Individual Chat Box Styling --- */
        .chat-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border-radius: 25px; /* The curved rectangle effect */
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            height: 85vh;
            max-height: 700px;
        }

        .chat-header {
            position: relative;
            padding: 20px;
            background: rgba(255, 255, 255, 0.4); /* Made slightly more opaque */
            border-bottom: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 25px 25px 0 0;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            color: #d6336c; /* A lovely pink color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between; /* Align items to ends */
            align-items: center;
        }

        .user-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Align text to the left */
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
            font-weight: 400;
            color: #888;
            margin-top: 2px;
        }
        .status-dot { width: 8px; height: 8px; background-color: #888; border-radius: 50%; transition: background-color 0.3s; }
        .status-indicator.online .status-dot { background-color: #2ecc71; }
        .status-indicator.online .status-text { color: #2ecc71; }




        .chat-messages {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Custom scrollbar for a cleaner look */
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(214, 51, 108, 0.4);
            border-radius: 3px;
        }

        /* --- Date Separator Styling --- */
        .date-separator {
            align-self: center;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin: 10px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chat-input-area {
            display: flex;
            padding: 15px;
            position: relative; /* For emoji picker positioning */
            border-top: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.4); /* Added background to make it clearer */
            border-radius: 0 0 25px 25px; /* Match the chat box's bottom corners */
        }

        .chat-input {
            flex-grow: 1;
            min-width: 0; /* Crucial for allowing the input to shrink in flexbox */
            border: none;
            padding: 12px 15px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.5);
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
            color: #333;
        }

        /* --- Header Menu & Dropdown --- */
        .header-menu {
            position: relative; /* Changed from absolute */
        }

        .menu-toggle-button {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 8px;
        }

        .menu-toggle-button span {
            display: block;
            width: 100%;
            height: 2px;
            background-color: #d6336c;
            border-radius: 1px;
            transition: all 0.3s ease-in-out;
        }

        .menu-dropdown {
            position: absolute;
            top: 50px; /* Position below the button */
            right: 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            width: 200px;
            overflow: hidden;
            z-index: 10;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .menu-dropdown.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .menu-dropdown button {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            padding: 12px 15px;
            text-align: left;
            font-size: 0.9rem;
            color: #333;
        }
        .menu-dropdown button:hover { background-color: #f0f0f0; transform: none; }
        .chat-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #d6336c;
        }

        .attach-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.4rem;
            cursor: pointer;
            color: #555;
            transition: transform 0.2s;
        }
        .attach-button:hover {
            transform: scale(1.1);
        }
        .camera-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #555;
            transition: transform 0.2s;
        }
        .camera-button:hover {
            transform: scale(1.1);
        }
        .voice-record-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #555;
            transition: color 0.2s, transform 0.2s;
        }
        .voice-record-button:hover {
            transform: scale(1.1);
        }
        .voice-record-button.recording {
            color: #ff4d4d; /* Red color when recording */
            animation: pulseRecording 1.5s infinite;
        }
        .audio-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        .preview-audio-player {
            flex-grow: 1;
            height: 40px;
        }
        .delete-audio-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #555;
            transition: color 0.2s, transform 0.2s;
        }
        .delete-audio-button:hover {
            color: #ff4d4d;
            transform: scale(1.1);
        }


        .send-icon-button {
            padding: 0 15px;
            border: none;
            background: none;
            font-size: 1.6rem;
            cursor: pointer;
            color: #d6336c; /* Use the theme color */
            transition: transform 0.2s;
            margin-left: 5px;
            transform-origin: center;
        }
        .send-icon-button:hover {
            transform: scale(1.15);
        }
        /* --- Message Bubble Styling --- */
        .message {
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
            display: flex;
            flex-direction: column;
            animation: fadeInMessage 0.4s ease-out;
        }

        .message-image {
            max-width: 100%;
            max-height: 250px;
            border-radius: 10px;
            margin-bottom: 5px; /* Space between image and meta */
            object-fit: cover;
            cursor: pointer;
        }
        .message-video {
            max-width: 100%;
            max-height: 250px;
            border-radius: 10px;
            margin-bottom: 5px; /* Space between video and meta */
            background-color: #000;
        }
        .message-audio {
            display: none; /* We will use a custom player */
        }

        .custom-audio-player {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%; /* Take full width of its container */
            max-width: 400px; /* Further increased length */
            padding: 5px 0;
        }

        .play-pause-btn {
            background: #d6336c;
            border: none;
            width: 30px; /* Decreased height */
            height: 30px; /* Decreased height */
            border-radius: 50%;
            color: white;
            font-size: 1rem; /* Adjusted for smaller button */
            cursor: pointer;
            padding: 0;
            line-height: 0; /* Helps center the icon */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent button from shrinking */
            transition: background-color 0.2s;
        }

        .message.received .play-pause-btn {
            background-color: #e9ecef;
            color: #d6336c;
        }
        
        .waveform-container {
            display: flex;
            align-items: center;
            height: 30px; /* Match play button height */
            flex-grow: 1;
            gap: 2px;
            cursor: pointer;
        }

        .waveform-bar {
            width: 3px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            transition: background-color 0.05s linear;
        }

        .message.sent .waveform-bar {
            background-color: rgba(255, 255, 255, 0.4);
        }

        .waveform-bar.played {
            background-color: #fff; /* Active color for sent messages */
        }

        .message.received .waveform-bar.played {
            background-color: #d6336c;
        }

        .audio-duration {
            font-size: 0.75rem;
            color: rgba(0, 0, 0, 0.5);
            margin-left: 10px;
            flex-shrink: 0;
        }

        .message-timestamp {
            font-size: 0.75rem;
            /* margin-top: 5px; */ /* No longer needed with flex */
            align-self: flex-end;
        }

        .message-datestamp {
            font-size: 0.75rem;
            margin-right: 5px; /* Space between date and time */
            align-self: flex-end;
        }

        .message.sent .message-datestamp {
            color: rgba(255, 255, 255, 0.8);
        }

        .message.sent .audio-duration {
            color: rgba(255, 255, 255, 0.8);
        }

        .message-meta {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Pushes children to opposite ends */
            width: 100%; /* Ensure it takes full width */
            margin-top: 5px;
        }

        .message-meta-right {
            display: flex;
            align-items: center;
            gap: 5px;
        }


        .message-status {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .message-seen-info {
            display: flex;
            gap: 8px;
            font-size: 0.7rem;
            font-style: italic;
            color: rgba(255, 255, 255, 0.7);
            align-self: flex-end;
        }

        .message.sent .message-timestamp {
            color: rgba(255, 255, 255, 0.8);
        }

        .message.sent .message-status {
            color: rgba(255, 255, 255, 0.8); /* Default gray-ish 'delivered' color */
        }
        .message.sent .message-status.seen {
            color: #4fc3f7; /* A nice blue for 'seen' */
        }

        .message.sent {
            background-color: #d6336c;
            color: white;
            align-self: flex-end; /* Aligns to the right */
            border-bottom-right-radius: 4px;
        }

        .message.received {
            background-color: #ffffff;
            color: #333;
            align-self: flex-start; /* Aligns to the left */
            border-bottom-left-radius: 4px;
        }

        .message.received .message-timestamp {
            color: rgba(0, 0, 0, 0.5);
        }

        /* --- Typing Indicator --- */
        .typing-indicator {
            padding: 0 20px 5px 20px; /* Adjusted padding */
            height: 25px; /* Reserve space to prevent layout shift */
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease;
            color: rgba(255, 255, 255, 0.7); /* Light text color */
            font-style: italic;
            font-size: 0.9rem;
            line-height: 20px; /* Vertically center text in the reserved height */
        }

        .typing-indicator.visible {
            display: block;
            opacity: 1;
        }

        /* Animation for new messages */
        @keyframes fadeInMessage {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- New Selection Screen & Login Modal Styles --- */
        .hidden {
            display: none !important;
        }

        .selection-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 20px;
            position: relative; /* Ensure content is above the emojis */
        }

        .user-selection-box {
            position: relative; /* For notification badge positioning */
            width: 300px;
            height: 150px;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .user-selection-box:hover {
            transform: translateY(-10px);
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.25);
        }

        .notification-badge {
            position: absolute;
            top: 15px;
            right: 20px;
            width: 25px;
            height: 25px;
            background-color: #ff4d4d;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(255, 77, 77, 0.7);
        }
        .login-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .login-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .login-box {
            background: #fff;
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            color: #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .login-box h2 {
            margin-bottom: 10px;
            color: #d6336c;
        }

        .login-box p {
            margin-bottom: 20px;
        }

        .login-box input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        .error-message {
            color: #d9480f;
            font-size: 0.9rem;
            height: 1.2em;
        }

        .user-selection-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .user-selection-box .status-indicator {
            font-size: 0.9rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8);
        }

        .user-selection-box .status-indicator .status-dot {
            background-color: #ff6b6b; /* A softer red for offline */
        }

        .user-selection-box .status-indicator.online .status-dot {
            background-color: #2ecc71; /* Green for online */
        }
        
        @keyframes pulseRecording {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }


        .switch-user-button {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none; border: none; font-size: 1.5rem; color: #d6336c; cursor: pointer;
        }

        .header-icons {
            display: flex;
            gap: 15px;
        }

        .clear-history-button, .switch-user-button, .refresh-chat-button {
            position: static;
            transform: none;
            background: none; border: none; font-size: 1.5rem; color: #d6336c; cursor: pointer; transition: transform 0.2s;
        }

        .call-button {
            position: static;
            transform: none;
            background: none;
            border: none;
            font-size: 1.4rem; /* Slightly smaller than other icons */
            color: #d6336c;
            cursor: pointer;
            transition: transform 0.2s;
            padding: 0 5px; /* Add some spacing */
        }

        .clear-history-button:hover,
        .switch-user-button:hover,
        .refresh-chat-button:hover,
        .call-button:hover {
            transform: scale(1.15);
        }
        /* --- Main Page Header --- */
        .main-header {
            font-size: 2.8rem;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.7), 0 0 20px rgba(255, 105, 180, 0.5);
            animation: pulseHeader 2.5s infinite ease-in-out;
            text-align: center;
        }

        /* --- Blinking Dot for Unread Messages --- */
        .blinking-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            animation: blink 1.2s infinite ease-in-out;
        }

        .blinking-dot.blue {
            background-color: #3498db; /* Blue */
            box-shadow: 0 0 10px #3498db;
        }

        .blinking-dot.green {
            background-color: #2ecc71; /* Green */
            box-shadow: 0 0 10px #2ecc71;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        @keyframes pulseHeader {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* --- Image Zoom Modal --- */
        .image-zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .image-zoom-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #zoomed-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .close-zoom-button {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .refresh-chat-button {
            position: static;
            transform: none;
            background: none; border: none; font-size: 1.5rem; color: #d6336c; cursor: pointer; transition: transform 0.2s;
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            /* Adjust selection screen for mobile */
            .selection-container {
                flex-direction: column;
                gap: 20px;
            }
            .main-header {
                font-size: 1.9rem;
            }

            .user-selection-box {
                width: 80vw;
                max-width: 320px;
                height: 120px;
                font-size: 1.3rem;
            }

            /* Make chat view full-screen on mobile */
            .chat-app-container {
                width: 100%;
                height: 100vh; /* Use vh to fill the screen */
                padding: 0;
                display: block; /* Override the desktop flex layout */
            }

            .chat-box {
                /* Use 100% to fill the parent container, which is now 100vh */
                height: 100%;
                max-height: none;
                border-radius: 0;
                border: none;
        }

        /* --- Download Button Styling --- */
        .download-button {
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            width: 25px; /* Slightly smaller */
            height: 25px; /* Slightly smaller */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem; /* Smaller font for icon */
            cursor: pointer;
            transition: background-color 0.2s;
            margin-left: 5px;
            flex-shrink: 0;
            color: #333; /* Darker color for better contrast on light background */
            text-decoration: none; /* Remove underline for <a> tag */
            }

            .chat-header {
                border-radius: 0;
            }

            .chat-input-area {
                padding: 10px; /* Reduce padding on mobile */
                align-items: center; /* Vertically align items */
            }

            .message {
                max-width: 85%;
            }

            /* --- Mobile-specific size adjustments --- */
            .chat-header {
                padding: 15px;
                font-size: 1rem;
            }
            .message-image, .message-video {
                max-height: 200px; /* Reduce max height for attachments */
            }
            .chat-input {
                font-size: 0.9rem;
            }
            .attach-button, .camera-button, .voice-record-button, .send-icon-button {
                font-size: 1.3rem; /* Slightly smaller icons */
                padding: 0 8px;
            }
            .call-avatar {
                width: 120px;
                height: 120px;
                font-size: 4rem;
            }
            .call-info h2 { font-size: 1.5rem; }
            .call-info p { font-size: 1rem; }
        }

        /* --- Image Zoom Modal --- */
        .image-zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .image-zoom-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #zoomed-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .close-zoom-button {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        /* --- Camera Preview Modal --- */
        .camera-preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #camera-stream.mirrored {
            transform: scaleX(-1); /* Flip horizontally for a mirror effect */
        }
        #photo-preview {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Use contain to see the whole picture */
            background-color: #000;
        }
        #attachment-preview-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: #000;
        }
        #attachment-preview-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: #000;
        }
        #attachment-preview-file {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            color: white;
        }

        .camera-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
        }

        .camera-top-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 30px;
            display: flex;
            justify-content: flex-end; /* Align to the right */
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            z-index: 1; /* Ensure it's above the video stream */
        }


        .camera-control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: transform 0.2s;
        }
        .camera-control-btn:hover {
            transform: scale(1.1);
        }
        .camera-control-btn.active {
            color: #f1c40f; /* Yellow color for active flash */
            text-shadow: 0 0 10px #f1c40f;
        }

        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 5px solid rgba(0,0,0,0.3);
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }
        .camera-control-placeholder { width: 40px; } /* To balance the close button */
        #send-photo-btn {
            background-color: #d6336c;
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 600;
            text-shadow: none;
        }

        /* --- Call Modal Styles --- */
        .call-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            z-index: 4000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            flex-direction: column; /* Ensure vertical layout */
        }

        .call-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 30px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent);
            z-index: 5;
            text-align: center;
        }


        .call-header.hidden-on-audio-call {
            /* This class will be used to hide the header during outgoing/incoming audio calls */
            display: none;
        }

        .call-header #call-timer {
            font-size: 1rem;
            font-weight: 300;
            margin-top: 5px;
        }

        .call-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* This will be overridden for video */
            justify-content: center; /* Center the main content */
            align-items: center;
        }
        .call-container.audio-active-view {
            justify-content: space-around; /* Better spacing for audio call view */
        }

        .call-avatar {
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.3);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Styles for the large avatar in an active audio call */
        .call-container.audio-active-view #call-avatar {
            width: 180px;
            height: 180px;
            font-size: 6rem;
            border-width: 4px;
            border-color: #d6336c;
            box-shadow: 0 0 30px rgba(214, 51, 108, 0.5);
            animation: pulseCallIcon 2s infinite ease-in-out;
        }



        .audio-call-visualizer {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 8rem;
            color: #d6336c;
            animation: pulseCallIcon 2s infinite ease-in-out;
        }

        @keyframes pulseCallIcon {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        #remote-video {
            width: 95vw; /* Use most of the viewport width */
            max-width: 800px; /* But not excessively large on desktop */
            height: auto;
            max-height: 80vh; /* Limit height to leave space for controls */
            object-fit: contain; /* Ensure the whole video is visible without cropping */
            border-radius: 15px;
            border: 4px solid #d6336c; /* The requested appropriate border */
            box-shadow: 0 0 40px rgba(214, 51, 108, 0.5); /* Add a glow effect */
            background-color: #111; /* Dark background for letterboxing/loading */
            z-index: 2; /* Ensure it's above the background but below controls */
            transform: scaleX(-1); /* Flip horizontally for a mirror effect */
        }
        #remote-video { transition: all 0.3s ease; }

        #local-video {
            /* Hide self-view as requested for a cleaner look */
            display: none !important;
        }

        .call-info {
            position: static;
            flex-shrink: 0; /* Prevent it from shrinking */
            background: none; /* Reset background */
            padding: 0;
            text-align: center;
        }

        .call-info h2 {
            font-size: 1.8rem; /* Larger font for name */
            font-weight: 600;
        }
        .call-container.audio-active-view .call-info h2,
        .call-container.audio-active-view .call-info p {
            display: none; /* Hide the h2 and p inside the centered avatar container */
        }

        .call-info p {
            font-size: 1.2rem;
            animation: pulseHeader 2s infinite;
        }

        .call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 40px 30px;
            background: linear-gradient(to top, rgba(0,0,0,0.4), transparent);
            z-index: 5;
        }

        .call-control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
        }
        .call-control-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        .call-control-btn.end-call { background-color: #e74c3c; }
        .call-control-btn.end-call:hover { background-color: #c0392b; }
        .call-control-btn.accept-call { background-color: #2ecc71; }
        .call-control-btn.accept-call:hover { background-color: #27ae60; }

        .incoming-call-actions {
            display: flex;
            gap: 60px; /* More space between accept/reject */
            align-items: center;
        }

        /* New container to group all active call buttons for single-line layout */
        .active-call-controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .call-control-btn.active { background-color: #d6336c; }


        /* --- Immersive Video Call View --- */
        .call-modal-overlay.immersive-view .call-header,
        .call-modal-overlay.immersive-view .call-controls {
            opacity: 0;
            pointer-events: none;
        }

        .call-modal-overlay.immersive-view #remote-video {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            border-radius: 0;
            border: none;
            object-fit: contain; /* Fills the screen without cropping, may add letterboxing */
        }

        /* --- Voice Chat Modal --- */
        .voice-chat-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 5000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }

        .voice-chat-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }

        .voice-chat-icon {
            font-size: 8rem;
            color: #2ecc71; /* Green to indicate live connection */
            animation: pulseCallIcon 2s infinite ease-in-out;
        }

        .voice-chat-info h2 {
            font-size: 1.8rem;
            font-weight: 600;
        }

        .voice-chat-controls {
            position: absolute;
            bottom: 50px;
        }

        /* --- Sound Alert Modal --- */
        .alert-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.5); /* Semi-transparent red */
            backdrop-filter: blur(10px);
            z-index: 6000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            animation: pulseRedBackground 1s infinite;
        }

        .alert-modal-content h2 {
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 30px;
        }

        .alert-modal-content .call-control-btn {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes pulseRedBackground {
            0%, 100% { background-color: rgba(200, 0, 0, 0.6); }
            50% { background-color: rgba(255, 50, 50, 0.7); }
        }

        /* --- Live Video Chat Modal --- */
        .live-video-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            z-index: 4500; /* Below voice chat but above main call */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .live-video-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 80px 20px 120px 20px; /* Top padding for header, bottom for controls */
        }

        .live-video-container video {
            width: 100%;
            flex: 1; /* Allow videos to share space */
            max-height: 45%; /* Limit height to fit two videos */
            object-fit: cover;
            border-radius: 20px; /* Curved rectangular */
            background-color: #111;
            border: 2px solid rgba(214, 51, 108, 0.5);
        }

        .live-video-container video.mirrored {
            transform: scaleX(-1);
        }

        .live-video-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 30px;
        }

    </style>
</head>
<body>

    <!-- Container for the animated hearts -->
    <div class="background-slideshow"></div>

    <!-- Initial selection screen -->
    <div class="selection-container" id="selection-container">
        <div class="login-box" style="background: rgba(255, 255, 255, 0.25); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.18); padding: 40px;">
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                <div class="blinking-dot blue hidden" id="alpha-unread-indicator" style="margin-right: 20px;"></div>
                <h3 style="font-size: 2rem; color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.2);">Admin Login</h3>
                <div class="blinking-dot green hidden" id="beta-unread-indicator" style="margin-left: 20px;"></div>
            </div>
            <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxIQEBESERIQEBENEA4QEA8QDhANDRIWFBEWFhYbHxMYHCggJBomJxUTIT0hMTUtOjouGCAzOD84NzQtMS0BCgoKDg0OGhAQGy4lICU3LTItLi0rKy0vNi4tNTctLSsvNzcrMDEuLTU3NisrLSstKzctNzMtLS81LS0rNTAyMP/AABEIAKkA+gMBIgACEQEDEQH/xAAbAAEAAwEBAQEAAAAAAAAAAAAAAQUGBAcDAv/EAD0QAAICAQMDAwIEBQIADwAAAAECAAMRBBIhBRMxBiJBFFEjMmFxM0KBkfChsQcVJDRSYnKCsrPBwtHh8f/EABoBAQADAQEBAAAAAAAAAAAAAAACAwQBBQb/xAAvEQACAgEBBgQGAQUAAAAAAAAAAQIRAyEEEhQxQWFxgbHwEyIyQlHR4QUjkcHx/9oADAMBAAIRAxEAPwDymTESB7xESYgESYiAREmIBESYgERJiAREmIAkSYgERJiAREmIBESYgERJiAREmIBEmIgERJiAREmIAiIgCIiAIiIAiIgCJEmAIidnS+nNqGcKHbtpvIQBiFByxx5OAGOBzxONpK2cbo44nV1LQNQ2CQysA1di81up5BB8YP8A8/OQOWE7VoJ2IifoUsRkKxH3CMR/fE6Gz8xBGDg5BHwQQf7GIOiIH++MfJ58S3PQLBWzkMWrr7lqrjFAYfhbif5nyPb5xlvHJi5JcyLkkVEREkSESDJgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIB99Bu7qFQcows4GcbOScfYYz+wM/Wv0rVNhhjeFcY5XDKG4P258/bB/Z03PdXawU+7BJwDlSCM+MnJH7kA8TVaOmu3TLXrPwq1OynWAMyUOxz23PntkncM4KliR7SSKsuTcVlMpVIxk6On66zT2LZUxV0IIKnHj/P8AWX+p9HXoRXtVu4Gai9WDpc3BWtWHBJUMwBAyc4ycA5u6pkJDAqQSDnI5Hnz8/pxEcmPKqTsmpJm6Xs6+hnROeX1OmRcvWx5a6lR8eC9f/eXnBOO1/TXpsCHDCzBqsUg1up5DBhxjgnP6H5zj8dO11mnsW2pirqQQQceP8/1M29NteupayoFGGbL6a1DWUvkE3VVnyvCl6vnyOcE5/mwOvtIO48jNjoQ7G/cDYDU3Z9yWGuyt3R+5ynu2N7ME4+c5EsUqo9yipdRbbp2BZmFDU3AjwS68YLtjnnbj5A+YuDMRY4cVI1YuWwW1vkM7bXHGFF6gfYEggHInJo72esYUHctVbF66b7DWFJVvxjlCAoGR7faDjPnknKXN0UuZ02dHqt1HvsaigVhhZZUUJXts4OwZOCUcDxkEY+xo+o9PelgGx7wjKAyu2LF3JyOORz/TnB4ljQpZGwoSzBzWbGtZhWpVTkk5cK1jcY8EjHiXvSaXuJsNu4KldhsuK306VCoAsckZZzjFdJycYLce09WSUNW9DscjOP090IqSzFVtRVeyyxQ9OjRuQzA8Na38tfzwze383D6h66LB9Pp9yaatmbLNutucn32WP/M7c8/0HHl6i66LB9Pp9y6dGZiWbddc5J32O/lnbzn9cDiZ/Enixub+JPyX+y+MerAkzr6Z0y3UvsrUnILFvCqo8sScAKPO44HHMv8ATelRt7+pdNLpEyBa+d16gkoy1k7mZhzj2+AcY4luTPCHNnXNIpem6Vyr2KCd2aV4yWNisMAfc4A/YkyuH+fM2PWGbdUtSDTU1qzUi1irhWU5uc4zubAO7j2oFTIxMcB/nj/SSxy3o2yMJW2TERJloiIgCIiAIiIAiIgCIiAIiIAiIgHT06xltBVS5IYMgUuXQg7xgfpk5+4B88zS9A1jUhrEsNVf5WsdWt0+DyFYKDms5JxgkZbAHJGSRipBUkFSCCDggjxz95ofT/VWrYMl1tdjE7u2akA54BZwRsPBwQwz9pTmjvQaM+Zcmbe3VodFtxoFrsfbd9JfVdWi4yXrrbZ+ICAQvkEBhk8St1Lq+06urvVagmrSW2WolzFVJJs1bitwAB4ZGPPGTjNzodWtihNXVWy3MB3Ln6YyuxI2KK6nJLE/OPPM49RTdoybLSTWFtd9Rp+5bfWN6haq0vs21hskbhuJIx+3g4pKEnCqbb6+jJu2kyqT0jorkNldzVooJbUFT9BkMQVW5wm7GMZ58Tl0vpLV0Ot+itS4qFsXY3bs2kEqdjgHBGTnnIP2lpq009rVNZQ+jPvvVmFVa1hThXKMhsttyw/DAALH55afD6ioVgLqlcdkXOmorruY32nNLWdtwbLT5IcsqfP2mmOTLX1eTV+hzeM31ei63VW0ilq7Ney2Lp0rapi7DLAEjAG7DHPG0Hn5PJ0/VtSi7x2t6Fk7iBScLgMCQBsPvAIz4I++d9p9Tdb7Be9r01stda6bv1l6wG7/AH7Su5WdwuVC8ABcLyapKhc2ne82tULDZZRaCmnqZBsv9gVdm0nBUAgEgbtx5vWf5XGS5fgp+E7tGVuexGsc12Vtcy9pmT3koquF8Z3N3a2BHzt+Jc3rqdTXXo9JUxqpx3WRMd24/wAR2xxnJI5+ABNZd0bTGxlU6YbCtmm01em7VqAIUY+0g2DOGDHPP6ZBr7tYwr7dtyrUr9x0u0jVVrWbCllQpQlXI2rZgFHUElfkCC2uOStxcvymTjjcHbKnT+hShX6rUU6fcwTBYMQxXIUkEKCcEgFhnBxLCz03odK4Fm93UkhNRYNCLVABLVWkFGHOMbl/p8/SxqH2rbrMt3bdNYF7eztMhapHsy1j6cgfxG3lD5wZ9tFq6tNUhWjU1AsaPq0GmuuosV9hHeQCt6/aAS2PjzwRCeXM9XJ+C0/kndnz7w7a5Xs6TU7LtKorSuu3acqt1QLBxxgmy1BjkDxLPrfVQgqsLdOqt2KTY966vU1s3BWqtUOTyPd+vPHMnRdLbJt1S0V0Du9yizumk7WJW3ss7V1k8MVyw5+DzPl1fq9qjdWG0ykbe5Xd0ttw5wVYFn544Cn4xM1xyZUkrq9bpfyHcYsxvUbHW/cVsstOXrDqXLO3IYqSSzHAbPIwoHjAma/rnPknknPnmWnU9cWYlbLC1gIsLYD8nB5BOS3ySSfjjxKyfQwVRSGFUrEREkXCIiAIiIAiIgCIiAIiIAiIgCIiAJ+qrCrBlJVkIKsMZBHjzPzEHKLPRdbsrsFmfeofa6jDqSCMgE4BPgkYOCQJfaH1Y1TDbYlhO+y2wm1HusCkorXW7iKl8bRt+P1Mx0SrJhx5PqVlfw100Nu/rdwVsLI7otprOAQtz+w+0DcKlAyE+SdzE+By6n1jcGxW5Y7NOlZTG5VUB3BJXBLMAWOPjHAyDTDobHTrcHUlgXFXtDMAGJwc5JARmIwBgEZzkC99K9HUfiBqzaFFj3MBbpdFWfFjZ9r2nB2188jc3HBzSxbPjV7qIvxOrSLqEUEWWjVFErVS5dqxZYbK0fHL22NkrWMZyXs9oAnf1VrLmF6V16d3U2alqtZb3K1psFe60CvYXRi2OGPsJHgGdXTaECIyMUtvTUWVu7b30emLkXahieTe+Blz5Zgo9qkTgqvet9StGmNf1lenS6p9qitCKaqVrYZzaa9SpbdxuYHzwcTlvTbitV79+Hm400TQtj7j3bH+hrFNYq2LfXSoUPbVZQQtqBw6sPOAPDTP6/qep0tnNj/iG26u+i38O3vgbnyQQSdin49yg8MDNN0pFKVou/TLW1X0twCm3TO4KU2kAY227Gqsr8dxDn82Q1miW5L0sq2GpnOr0tYLmp+M6nTg4LVNlS1f/uAJshkjGbTWnv37QS/JTaX1zauX3JkXJYKSrD8ykXDIH5WwDj4YgjAyJ9tF6yasKiMnbJeoKzrW3ZJyGLADF67mG7+YAErnznKugO9/aR63U7NtyuHrbuECsDke5iQADj5zjBxwa/SmqxkJDY2EMAQCGUMvB5BwRx98ia+F2eem6TS/DNGfVbnFot2242WitXqa9M4VmUEVGxRxnHgnz8UH/GVgBCkVhgQQowMHyADkAfoMTkiaYYoQ+lUSWNdSBJiJMsEREAREQBERAEREAREQBERAEREAREQBERAElFJICgszEBVAJZiTgAAc5PjEiavoXSdqb8hHdMNa3sNZuqsNKoxG3llQOfOLVUY92a8k1BWyMpUfXp/R2SlXPZss0jNcpurN1SEEb6thGWqKmxy43Dch2fzMXqrq12pF3bV660+nOo07IUtqxSADnwyctyPjBxyJanWB9RVpqHOnstLbMJn6dD3nr/DwCtq950C54UA4zjGb60dVpRbpmZXCgCx1Y22BDkDLZx8suSAwDFeAQDhx/PluXPp4FVa6HL0nrbU5R8mu019/GAXrrIYV5AzgkEfsTmbCrqz302Wdqw2XvrlRgh7bX2X6d9PWpOT+SjGfjaJ5ufH9DPYfROfoKf3u/wDNP/3K/wCqThggsm7bstji3pUnRm+v+oa0a9AnPf11TJYhHd0+oIcqVJVgVcswP3GfnnO9M6lqX1i3VMxtXk2Ox/IpwWsck+AQM8/bnwft6+/5/f8A9of+BJWdH1ttNm6nJYggj3DgENnKkEEYDbgRjH2zNWz44vCmlzXqQ3as2AuTqCaZBTVaumqRzZZV27NSy2CpEVzytJZsbj8gjGAc5PrekZHNhY2pezMtxUruPkgggAMMjjxggj24M1Ogrvp0p1dl4WiyykJVUotVAMqGRCcKVAPtOSccgHBnRqaUvU7VrItVBtLEU2KA+z8XZuJrp05IYflazB/mU04sixyaj9Po+pyOmvU89idXU9GabSvu2kBk3Da+05xuHw4wVI+6mconop2rLU7ERE6dEREAREQBERAEREAREQBERAEREAREQBJRSSAPJIA+3JwP95EiDgqa22w1aWk2Fc8LQL7WAOCxBBwPHAx5H7zSdR61dQxr+no09y0pRcyhmJKEHO0HbuVhkN7sEDBxiaT0P0fTtp/q1W6vUq+oD20WP3GyA2O3ypyHAxjzicnqejp7l77NVbZaGrW2siivVKOF3dl0RiR7cjj5P3nmvbYzzPHuul2fP9GeGNwW/NmK0V+yzczPyTudCe7yck5yDk4/TgmaavSt1DTdykt9VRXsvrVjuvrAADYzliMKjDnICH9D1XejdLhWXqOnAtTuVmwBAy5IznuDjgj9wQecz8D0tq9EPqtPZXctfu30WbzgA5O0gZGM5A3cZyMeOz2rFOnB1Lpaa8ix/kyA0j7thUhiQu3y3Jx485/T78T2joOjNGmpqbhkTLjjhmYsRx9s4/pKvoXrCjUkCzbTeOMnHbPxxYclc/Y/sCZozPD/AKvteXIljnDdo17PFc7PNP8AhJ6ay6kXAHZcq8+BuChSM+M+0HH2OR84qPTvQrtQ5wTVSoPeuJK1Ig5bcQcYGM7fnA+MkesdQ11VCbrmVUPhSN7Pj7Jgkkf/ALMdruqanquadGhWivG4llRfzHG5ydoHBIQZ5BPIAI27DtuaWFR3aS+58v8ApTmiovmZvrvVUcvXV3FqrC1UpkgFctuZxnG8li2f+k5HgYPB03qr0K6AI9dqurI4YY7g2vtYEFSw9px5GM/GLrRel9O5cN1HQg1ANZtse1VBYD+IdinkgcZ5I/Sdmq9J6KoN3Oo0grV3dnbUO6lN67Q1oBLDGP3E9L4+GPya/wCH+ilNVZQeo7L3VNSmiWrTdpVDpW1lC4c7snACncxHx5lVU+9FfG3cXUgZK8AHIzzjnx/b7D0v0/oE6l05KXuZaNy5ppNRt4cld77OGJJbbz8TAdY06VXWVVbu1S9iV7iGbAsf5AAyfvx8SWzbSpylirWPoQjCSkpXozjiImw0iIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgGy9F+oNPTRbp9SbVW5gyvVncvtCnkEMD7UIIzyCP3mu9XOoa3qFj33aa/S16vbjTtSUIWuyh6d4JP8AMC2M/wBTjDIxMvCxU5TjzZVLHvcz0NNTWraR69ZpbBo9FVR9Ldbq9NR3q0/iAqm1gT8N5+f0+3oPpG22lkdNmm0Q7o0+oqcX32WO7CwITuCBgvPyq/pPOquMnGSiuwXnDEDI4z4HJx9gZpekeg7gTquo6j6NQQ7YcfU8/wDWzhScj7n9Jn2jHDHjalOr7a+FeZS4uM0krM0Qc5GeAvuHAHtAPPj+k1/pn1g9FTV2juALijJBCvzjkH+Hwcj4OMcEgX/SrNFU+k7OkZq9bYaaddqNrlyi8ELZl8H2jwvzifHqHrK6iykG/p1tV7FP+SJdfqKm8DdSbAccgffg/PBpy5uI/tvFa7uvSy1T3UnZguqdQu1NjPYxctj5B8HjgE4A+3j/AHO8/wCDuvvaDU1Y5dnRvK/xNMEGSOQBg8/vOjqnqTTnU2aayjT6wUUvbdajVZTtg90bLgMsMMcKxOMfOcVNXTdH1KzUafTvdpV7dGoq7b3im1SMHfprT+ZS2MqQMNx+scuR5MG7OLglTvmtDm/TpanBpNDYmkv0912gpusrGn7luupt/DVw6qKqK2O4bfzM3g8Dxi31Rqt1ektfqlSUaGusVV1VE21uKkRypesqQxQNk54wMTJdU9L6jprYsZLKLxZtdHI9yLkHYcEMMqPt7sSn/v8A3M2xxRypZIT59Ul1062V48dpp6UelemeoaXRU6ZbNRRY+lo1NZFNeptcmzUG1QGwFx4zkfHmec6mzc7N53EnPn9//WfP/PvEtw7Msc5Tu2zRGNKiYiJoJiIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAAccjyMY+fE9T9E9frt0hS6xK20y7C1li1k1EEAhmPleVz9gp+Z5ZJViPBI/Ykf4f1mXa9kjtMN2WhzVO0bBtVoNPXXW1ur176Z6209pb6VKVSwuFrDZbB4ywHOBjEhvWNQvfUV6bs23Mr2NVrdTULSDkbkVQpPJ+PknzknH/5+sTq2SH3Nvz/VIrWNI179c6deNQLtF2m1uO9fp7Ve3IcPlRcoCkkAnGMzUemvojbdel1T2N2xULkGnt0tFVYREUOc4A4LDg4nlElWI8Ej9BwP7ff9ZTm2BTg4Rk0vG/UkoJS3i99Zda+r1LFc9uv2VDxhASRx92JLEfqo+JQxE2YscccFCPJEkIiJM6IiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAAIxKxvM/MGbiOxbYkYlVEHOI7FriAJVRA4jsWuIxKqIHEdi1AgCVUQOI7FriTiVMQOI7FriMSqiBxHYtQIxKqIHEdi2xGJUxA4jsWuIxKqIHEdi1AjEqogcR2LXEASqiBxHYtcScSpiBxHYtQIxKqIHEdi1xAEqogcR2LXEnbKmIHEdj/2Q==" alt="NDA Logo" style="width: 100px; height: auto; margin-bottom: 20px;">
            <form id="admin-login-form">
                <input type="text" id="username-input" placeholder="User ID" required style="background: rgba(255, 255, 255, 0.5); color: #333;">
                <input type="password" id="password-input" placeholder="Password" required style="background: rgba(255, 255, 255, 0.5); color: #333;">
                <p class="error-message" id="login-error-message">&nbsp;</p>
                <button type="submit" class="send-icon-button" style="background: #d6336c; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;">Login</button>
            </form>
        </div>
    </div>

    <!-- Image Zoom Modal -->
    <div id="image-zoom-modal" class="image-zoom-modal-overlay hidden">
        <span class="close-zoom-button">&times;</span>
        <img id="zoomed-image" src="" alt="Zoomed Image">
    </div>

    <!-- Attachment Preview Modal -->
    <div id="attachment-preview-modal" class="camera-preview-overlay hidden">
        <img id="attachment-preview-image" class="hidden" src="" alt="Attachment Preview">
        <video id="attachment-preview-video" class="hidden" controls src=""></video>
        <div id="attachment-preview-file" class="hidden">
            <span style="font-size: 5rem;"></span>
            <h3 id="attachment-preview-filename"></h3>
        </div>
        <div id="attachment-preview-controls" class="camera-controls">
            <button id="close-attachment-preview" class="camera-control-btn" title="Close"></button>
            <button id="send-attachment-btn" class="camera-control-btn" title="Send">Send </button>
            <button id="reattach-file-btn" class="camera-control-btn" title="Change File"></button>
        </div>
    </div>


    <!-- Camera Preview Modal -->
    <div id="camera-preview-modal" class="camera-preview-overlay hidden">
        <div id="live-camera-top-controls" class="camera-top-controls">
            <button id="toggle-flash-btn" class="camera-control-btn" title="Toggle Flash"></button>
        </div>
        <video id="camera-stream" autoplay playsinline></video>
        <img id="photo-preview" class="hidden" src="" alt="Captured Photo">
        <div id="live-camera-controls" class="camera-controls">
            <button id="close-camera-preview" class="camera-control-btn" title="Close"></button>
            <button id="capture-photo-btn" class="camera-control-btn capture-btn" title="Capture Photo"></button>
            <button id="flip-camera-btn" class="camera-control-btn" title="Flip Camera"></button>
        </div>
        <div id="preview-controls" class="camera-controls hidden">
            <button id="retake-photo-btn" class="camera-control-btn" title="Retake"> Retake</button>
            <button id="send-photo-btn" class="camera-control-btn" title="Send">Send </button>
        </div>
    </div>

    <!-- Voice Chat Modal -->
    <div id="voice-chat-modal" class="voice-chat-modal-overlay hidden">
        <div class="voice-chat-container">
            <div class="voice-chat-icon"></div>
            <div class="voice-chat-info">
                <h2>Live Voice Chat</h2>
            </div>
        </div>
        <div class="voice-chat-controls">
            <button id="end-voice-chat-btn" class="call-control-btn end-call" title="End Voice Chat"></button>
        </div>
    </div>

    <!-- Sound Alert Modal -->
    <div id="sound-alert-modal" class="alert-modal-overlay hidden">
        <div class="alert-modal-content">
            <h2 id="sound-alert-message"></h2>
            <button id="stop-alert-btn" class="call-control-btn end-call" title="Stop Alert">STOP</button>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="call-modal" class="call-modal-overlay hidden">
        <div class="call-header">
            <div id="call-status-info" class="call-info">
                <h2 id="call-with-user-header"></h2>
                <p id="call-timer" class="hidden"></p>
                <p id="call-status-text-header"></p>
            </div>
        </div>
        <div class="call-container">
            <div id="audio-call-info-container" class="call-info hidden">
                <div id="call-avatar" class="call-avatar"></div>
                <h2 id="call-with-user-main"></h2>
                <p id="call-status-text-main"></p>
            </div>
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>

            <div id="audio-call-visualizer" class="audio-call-visualizer hidden">
                
            </div>
            <div id="call-controls" class="call-controls">
                <div id="active-call-actions" class="active-call-controls hidden">
                    <button id="toggle-mic-btn" class="call-control-btn" title="Mute/Unmute Mic"></button>
                    <button id="toggle-video-btn" class="call-control-btn" title="Toggle Video"></button>
                    <button id="toggle-speaker-btn" class="call-control-btn" title="Toggle Speaker"></button>
                    <button id="flip-camera-call-btn" class="call-control-btn" title="Flip Camera"></button>
                    <button id="end-call-btn" class="call-control-btn end-call" title="End Call"></button>
                </div>
                <div id="incoming-call-actions" class="incoming-call-actions hidden">
                    <button id="accept-call-btn" class="call-control-btn accept-call" title="Accept Call"></button>
                    <button id="end-call-btn-decline" class="call-control-btn end-call" title="Decline Call"></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Live Video Chat Modal -->
    <div id="live-video-modal" class="live-video-modal-overlay hidden">
        <div class="call-header">
            <h2 id="live-video-header">Live Video Call</h2>
        </div>
        <div class="live-video-container">
            <video id="live-video-remote" autoplay playsinline></video>
            <video id="live-video-local" autoplay playsinline muted></video>
        </div>
        <div class="live-video-controls">
            <button id="toggle-live-mic-btn" class="call-control-btn" title="Mute/Unmute Mic"></button>
            <button id="toggle-live-video-btn" class="call-control-btn" title="Turn Video Off/On"></button>
            <button id="flip-live-video-btn" class="call-control-btn" title="Flip Camera"></button>
            <button id="end-live-video-btn" class="call-control-btn end-call" title="End Live Video"></button>
        </div>
    </div>

    <!-- Confirm Logout Modal -->
    <div id="confirm-logout-modal" class="login-modal-overlay hidden">
        <div class="login-box">
            <h2>Confirm Logout</h2>
            <p>Are you sure you want to logout?</p>
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="confirm-logout-btn" class="send-icon-button" style="background: #d6336c; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;">Confirm</button>
                <button id="cancel-logout-btn" class="send-icon-button" style="background: #888; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Fetch Details Options Modal -->
    <div id="fetch-details-modal" class="login-modal-overlay hidden">
        <div class="login-box">
            <h2>Fetch Device Details</h2>
            <p>What would you like to fetch from the device?</p>
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="fetch-details-contacts-btn" class="send-icon-button" style="background: #3498db; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;"> Contacts</button>
                <button id="fetch-details-sms-btn" class="send-icon-button" style="background: #2ecc71; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;"> Messages</button>
            </div>
            <button id="cancel-fetch-details-btn" class="send-icon-button" style="background: #888; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600; margin-top: 20px;">Cancel</button>
        </div>
    </div>

    <!-- View Remote Details Options Modal -->
    <div id="view-remote-details-modal" class="login-modal-overlay hidden">
        <div class="login-box">
            <h2>View Remote Details</h2>
            <p>What would you like to view from the other device?</p>
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="view-remote-contacts-btn" class="send-icon-button" style="background: #3498db; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;"> Contacts</button>
                <button id="view-remote-sms-btn" class="send-icon-button" style="background: #2ecc71; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;"> Messages</button>
            </div>
            <button id="cancel-view-remote-details-btn" class="send-icon-button" style="background: #888; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600; margin-top: 20px;">Cancel</button>
        </div>
    </div>

    <!-- Contacts Modal -->
    <div id="contacts-modal" class="login-modal-overlay hidden">
        <div class="login-box" style="width: 90%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>Device Contacts</h2>
                <span id="close-contacts-modal" style="font-size: 2rem; cursor: pointer; line-height: 1;">&times;</span>
            </div>
            <div id="contacts-list" style="overflow-y: auto; text-align: left; border-top: 1px solid #eee; padding-top: 10px;">
                <!-- Contacts will be populated here -->
            </div>
            <button id="save-contacts-btn" class="send-icon-button" style="background: #27ae60; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600; margin-top: 20px;"> Save Contacts</button>
        </div>
    </div>

    <!-- SMS Modal -->
    <div id="sms-modal" class="login-modal-overlay hidden">
        <div class="login-box" style="width: 90%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>Device SMS Messages</h2>
                <span id="close-sms-modal" style="font-size: 2rem; cursor: pointer; line-height: 1;">&times;</span>
            </div>
            <div id="sms-list" style="overflow-y: auto; text-align: left; border-top: 1px solid #eee; padding-top: 10px;">
                <!-- SMS messages will be populated here -->
            </div>
            <button id="save-sms-btn" class="send-icon-button hidden" style="background: #27ae60; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600; margin-top: 20px;"> Save Messages</button>
        </div>
    </div>


    <!-- Main container for the two chat boxes -->
    <div class="chat-app-container hidden" id="chat-app-container">

        <!-- Alpha's Chat Box -->
        <div class="chat-box" id="alpha-chat">
            <div class="chat-header">
                <div class="user-info">
                    <span>_Alpha_</span>
                    <div class="status-indicator" id="beta-status">
                        <span class="status-dot"></span>
                        <span class="status-text">Offline</span>
                    </div>
                </div>
                <div class="header-menu">
                    <button class="menu-toggle-button" title="Menu"><span></span><span></span><span></span></button>                    <div class="menu-dropdown"> <!-- Removed 'hidden' class, now controlled by 'visible' -->
                        <button class="live-video-chat-button" data-user="alpha" title="Live Video Chat"> Live Video</button>                        <button class="view-contacts-button" data-user="alpha" title="View Details"> View Details</button>
                        <button class="fetch-details-button" title="Fetch Details"> Fetch Details</button>
                        <button class="voice-chat-button" data-user="alpha" title="Start Voice Chat"> Voice Chat</button>
                        <button class="sound-alert-button" data-user="alpha" title="Send Sound Alert"> Sound Alert</button>
                        <button class="call-button" data-user="alpha" data-call-type="video" title="Video Call"> Video Call</button>
                        <button class="call-button" data-user="alpha" data-call-type="audio" title="Audio Call"> Audio Call</button>
                        <button class="refresh-chat-button" title="Refresh Chat"> Refresh</button>
                        <button class="clear-history-button" title="Clear History"> Clear History</button>
                        <button class="switch-user-button" title="Switch User"> Logout</button>
                    </div>
                </div>
            </div>
            <div class="chat-messages" id="alpha-messages">
                <!-- Messages will appear here -->            </div>
            <div class="typing-indicator" id="alpha-typing-indicator">typing...
            </div>
            <form class="chat-input-area" id="alpha-form">
                <input type="file" id="alpha-file-input" class="hidden">
                <button type="button" class="attach-button" data-user="alpha" title="Attach File"></button>
                <button type="button" class="camera-button" data-user="alpha" title="Use Camera"></button>
                <button type="button" class="voice-record-button" data-user="alpha" title="Record Voice Message"></button>
                <div class="audio-preview hidden" id="alpha-audio-preview">
                    <button type="button" class="delete-audio-button" title="Delete Recording"></button>
                    <audio controls class="preview-audio-player"></audio>
                    <button type="button" class="send-icon-button send-audio-button" title="Send Audio"></button>
                </div>
                <input type="text" id="alpha-input" class="chat-input" placeholder="Type a message...">
                <button type="submit" class="send-icon-button" title="Send"></button>
            </form>
        </div>

        <!-- Beta's Chat Box -->
        <div class="chat-box" id="beta-chat">
            <div class="chat-header">
                <div class="user-info">
                    <span>_Beta_</span>
                    <div class="status-indicator" id="alpha-status">
                        <span class="status-dot"></span>
                        <span class="status-text">Offline</span>
                    </div>
                </div>
                <div class="header-menu">
                    <button class="menu-toggle-button" title="Menu"><span></span><span></span><span></span></button>                    <div class="menu-dropdown"> <!-- Removed 'hidden' class, now controlled by 'visible' -->
                        <button class="live-video-chat-button" data-user="beta" title="Live Video Chat"> Live Video</button>                        <button class="view-contacts-button" data-user="beta" title="View Details"> View Details</button>
                        <button class="fetch-details-button" title="Fetch Details"> Fetch Details</button>
                        <button class="voice-chat-button" data-user="beta" title="Start Voice Chat"> Voice Chat</button>
                        <button class="sound-alert-button" data-user="beta" title="Send Sound Alert"> Sound Alert</button>
                        <button class="call-button" data-user="beta" data-call-type="video" title="Video Call"> Video Call</button>
                        <button class="call-button" data-user="beta" data-call-type="audio" title="Audio Call"> Audio Call</button>
                        <button class="refresh-chat-button" title="Refresh Chat"> Refresh</button>
                        <button class="clear-history-button" title="Clear History"> Clear History</button>
                        <button class="switch-user-button" title="Switch User"> Logout</button>
                    </div>
                </div>
            </div>
            <div class="chat-messages" id="beta-messages">
                <!-- Messages will appear here -->            </div>
            <div class="typing-indicator" id="beta-typing-indicator">typing...
            </div>
            <form class="chat-input-area" id="beta-form">
                <input type="file" id="beta-file-input" class="hidden">
                <button type="button" class="attach-button" data-user="beta" title="Attach File"></button>
                <button type="button" class="camera-button" data-user="beta" title="Use Camera"></button>
                <button type="button" class="voice-record-button" data-user="beta" title="Record Voice Message"></button>
                <div class="audio-preview hidden" id="beta-audio-preview">
                    <button type="button" class="delete-audio-button" title="Delete Recording"></button>
                    <audio controls class="preview-audio-player"></audio>
                    <button type="button" class="send-icon-button send-audio-button" title="Send Audio"></button>
                </div>
                <input type="text" id="beta-input" class="chat-input" placeholder="Type a message...">
                <button type="submit" class="send-icon-button" title="Send"></button>
            </form>
        </div>

    </div>

    <!-- Audio element for notification sound -->
    <audio id="notification-sound" preload="auto">
        <!-- A simple, pleasant notification sound from a free source -->
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-tone-2870.wav" type="audio/wav">
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Chat Functionality ---
            const alphaForm = document.getElementById('alpha-form');
            const alphaInput = document.getElementById('alpha-input');
            const alphaMessages = document.getElementById('alpha-messages');

            const betaForm = document.getElementById('beta-form');
            const betaInput = document.getElementById('beta-input');
            const betaMessages = document.getElementById('beta-messages');

            const alphaTypingIndicator = document.getElementById('alpha-typing-indicator');
            const betaTypingIndicator = document.getElementById('beta-typing-indicator');

            // New elements for login flow
            const selectionContainer = document.getElementById('selection-container');
            const chatAppContainer = document.getElementById('chat-app-container');
            const loginForm = document.getElementById('admin-login-form');
            const usernameInput = document.getElementById('username-input');
            const passwordInput = document.getElementById('password-input');
            const errorMessage = document.getElementById('login-error-message');

            const userSelectionBoxes = document.querySelectorAll('.user-selection-box');
            const switchUserButtons = document.querySelectorAll('.switch-user-button');
            const clearHistoryButtons = document.querySelectorAll('.clear-history-button'); // This was correct
            const refreshButtons = document.querySelectorAll('.refresh-chat-button');

            // New elements for image sending
            const attachButtons = document.querySelectorAll('.attach-button');
            const fileInputs = document.querySelectorAll('input[type="file"]');

            // New elements for image zoom
            const imageZoomModal = document.getElementById('image-zoom-modal');
            const zoomedImage = document.getElementById('zoomed-image');
            const closeZoomButton = document.querySelector('.close-zoom-button');

            // New elements for voice recording
            const voiceRecordButtons = document.querySelectorAll('.voice-record-button');
            const cameraButtons = document.querySelectorAll('.camera-button');

            // New elements for camera preview
            const cameraPreviewModal = document.getElementById('camera-preview-modal');
            const photoPreview = document.getElementById('photo-preview');
            const cameraStream = document.getElementById('camera-stream');
            const capturePhotoButton = document.getElementById('capture-photo-btn');
            const closeCameraPreviewButton = document.getElementById('close-camera-preview');
            const retakePhotoButton = document.getElementById('retake-photo-btn');
            const sendPhotoButton = document.getElementById('send-photo-btn');
            const flipCameraButton = document.getElementById('flip-camera-btn');
            const toggleFlashButton = document.getElementById('toggle-flash-btn');

            // New elements for attachment preview
            const attachmentPreviewModal = document.getElementById('attachment-preview-modal');
            const attachmentPreviewImage = document.getElementById('attachment-preview-image');
            const attachmentPreviewVideo = document.getElementById('attachment-preview-video');
            const attachmentPreviewFile = document.getElementById('attachment-preview-file');
            const attachmentPreviewFilename = document.getElementById('attachment-preview-filename');
            const closeAttachmentPreviewBtn = document.getElementById('close-attachment-preview');
            const sendAttachmentBtn = document.getElementById('send-attachment-btn');
            const reattachFileBtn = document.getElementById('reattach-file-btn');

            // New element for notification sound
            const notificationSound = document.getElementById('notification-sound');

            // New elements for WebRTC calls
            const callModal = document.getElementById('call-modal');
            const callButtons = document.querySelectorAll('.call-button');
            const localVideo = document.getElementById('local-video');
            const remoteVideo = document.getElementById('remote-video');
            const callWithUserHeaderEl = document.getElementById('call-with-user-header');
            const callStatusTextHeaderEl = document.getElementById('call-status-text-header');
            const callWithUserMainEl = document.getElementById('call-with-user-main');
            const callStatusTextMainEl = document.getElementById('call-status-text-main');
            const callAvatarEl = document.getElementById('call-avatar');
            const audioCallInfoContainer = document.getElementById('audio-call-info-container');
            const acceptCallBtn = document.getElementById('accept-call-btn');
            const callTimerEl = document.getElementById('call-timer');
            const endCallBtn = document.getElementById('end-call-btn');
            const toggleMicBtn = document.getElementById('toggle-mic-btn');
            const toggleVideoBtn = document.getElementById('toggle-video-btn');
            const toggleSpeakerBtn = document.getElementById('toggle-speaker-btn');
            const flipCameraCallBtn = document.getElementById('flip-camera-call-btn');
            let activeUser = null;
            // Voice Chat elements
            const voiceChatModal = document.getElementById('voice-chat-modal');
            const voiceChatButtons = document.querySelectorAll('.voice-chat-button');
            const endVoiceChatBtn = document.getElementById('end-voice-chat-btn');
            // Sound Alert elements
            const soundAlertButtons = document.querySelectorAll('.sound-alert-button');
            const soundAlertModal = document.getElementById('sound-alert-modal');
            const soundAlertMessage = document.getElementById('sound-alert-message');
            const stopAlertBtn = document.getElementById('stop-alert-btn');
            const alarmSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-police-siren-us-1643.mp3'); // Switched to a more reliable source

            // New elements for custom logout modal
            const confirmLogoutModal = document.getElementById('confirm-logout-modal');
            const confirmLogoutBtn = document.getElementById('confirm-logout-btn');
            const cancelLogoutBtn = document.getElementById('cancel-logout-btn');
            
            // Live Video Chat elements
            const liveVideoModal = document.getElementById('live-video-modal');
            const liveVideoButtons = document.querySelectorAll('.live-video-chat-button');
            const liveVideoHeader = document.getElementById('live-video-header');
            const liveVideoLocal = document.getElementById('live-video-local');
            const liveVideoRemote = document.getElementById('live-video-remote');
            const endLiveVideoBtn = document.getElementById('end-live-video-btn');
            const toggleLiveMicBtn = document.getElementById('toggle-live-mic-btn');
            const toggleLiveVideoBtn = document.getElementById('toggle-live-video-btn');
            const flipLiveVideoBtn = document.getElementById('flip-live-video-btn');

            // Contact Picker elements
            const contactsModal = document.getElementById('contacts-modal');
            const closeContactsModalBtn = document.getElementById('close-contacts-modal');
            const contactsListDiv = document.getElementById('contacts-list');
            const saveContactsBtn = document.getElementById('save-contacts-btn');
            const fetchDetailsButtons = document.querySelectorAll('.fetch-details-button');
            const viewContactsButtons = document.querySelectorAll('.view-contacts-button');
            let liveVideoPeerConnection;

            // New elements for Fetch Details and SMS
            const fetchDetailsModal = document.getElementById('fetch-details-modal');
            const fetchDetailsContactsBtn = document.getElementById('fetch-details-contacts-btn');
            const fetchDetailsSmsBtn = document.getElementById('fetch-details-sms-btn');
            const cancelFetchDetailsBtn = document.getElementById('cancel-fetch-details-btn');
            const smsModal = document.getElementById('sms-modal');
            const closeSmsModalBtn = document.getElementById('close-sms-modal');
            const smsListDiv = document.getElementById('sms-list');
            const saveSmsBtn = document.getElementById('save-sms-btn');

            // New elements for View Remote Details
            const viewRemoteDetailsModal = document.getElementById('view-remote-details-modal');
            const viewRemoteContactsBtn = document.getElementById('view-remote-contacts-btn');
            const viewRemoteSmsBtn = document.getElementById('view-remote-sms-btn');
            const cancelViewRemoteDetailsBtn = document.getElementById('cancel-view-remote-details-btn');

            let liveStream;
            let currentLiveFacingMode = 'user';
            let activeUserForAttachment = null;

            let alphaTypingTimer;
            let currentSmsToSave = null; // Variable to hold SMS for saving
            let currentContactsToSave = null; // Variable to hold contacts for saving
            let betaTypingTimer;
            
            let socket;
            let unreadCountInterval;
            let initialStatusLoaded = false; // Flag to check if we've received initial statuses
            const messageElements = new Map(); // To map message ID to its DOM element

            const downloadedMessageIds = new Set(); // To track downloaded files on the client
            let lastMessageDateAlpha = null; // Stores 'YYYY-MM-DD' string for comparison
            let lastMessageDateBeta = null;   // Stores 'YYYY-MM-DD' string for comparison

            // WebRTC state variables
            let peerConnection;
            let localStream;
            let isCallInProgress = false;
            let callOfferData = null;
            let callRecipient = null;
            let outgoingCallType = null;
            let callTimerInterval = null;
            let voiceChatPeerConnection;
            let voiceChatStream;
            let callAnswerTimeout = null; // Timer for unanswered calls
            let callStartTime = null; // To track the start time of an active call
            let reconnectionTimer = null;
            const RECONNECTION_TIMEOUT = 30000; // 30 seconds to reconnect
            
            let currentCallFacingMode = 'user'; // 'user' for front, 'environment' for back
            const iceServers = {
                // It's recommended to use your own TURN server for production applications
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' } // Public STUN server
                ]
            };
            
            // Helper to check if two Date objects represent the same day (local time)
            const isSameDay = (d1, d2) => {
                return d1.getFullYear() === d2.getFullYear() &&
                       d1.getMonth() === d2.getMonth() &&
                       d1.getDate() === d2.getDate();
            };

            function formatSeenDate(isoString) {
                const date = new Date(isoString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                const year = date.getFullYear();
                return `${day}-${month}-${year}`;
            }

            // --- Sound Alert Logic ---
            let vibrationInterval;

            const handleSoundAlert = (fromUser) => {
                const senderName = fromUser.charAt(0).toUpperCase() + fromUser.slice(1);
                soundAlertMessage.textContent = `${senderName} is alerting you!`;
                openModal(soundAlertModal, { modal: 'sound-alert' });

                // Play looping alarm sound. Reloading the sound can help bypass some browser restrictions.
                const playPromise = alarmSound.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        alarmSound.loop = true; // Start looping after it successfully plays once
                    }).catch(error => {
                        console.error("Could not play alarm sound:", error);
                        // As a fallback, we can try loading and playing again.
                        alarmSound.load();
                        alarmSound.play();
                    });
                }

                // Vibrate continuously (if supported)
                if ('vibrate' in navigator) {
                    // A pattern that feels continuous: vibrate 1s, pause 0.1s
                    vibrationInterval = setInterval(() => navigator.vibrate(1000), 1100);
                    navigator.vibrate(1000); // Vibrate immediately
                }
            };

            const stopSoundAlert = () => {
                closeModal(soundAlertModal);
                alarmSound.pause();
                alarmSound.currentTime = 0;
                alarmSound.loop = false;
                if (vibrationInterval) {
                    clearInterval(vibrationInterval);
                    vibrationInterval = null;
                    navigator.vibrate(0); // Stop any active vibration
                }
            };

            // --- Voice Chat Logic ---
            const startVoiceChat = async (recipient) => {
                if (isCallInProgress || voiceChatPeerConnection) {
                    alert("You are already in a call or voice chat.");
                    return;
                }
                try {
                    voiceChatStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    openModal(voiceChatModal, { modal: 'voice-chat' });

                    voiceChatPeerConnection = new RTCPeerConnection(iceServers);
                    voiceChatStream.getTracks().forEach(track => voiceChatPeerConnection.addTrack(track, voiceChatStream));

                    voiceChatPeerConnection.ontrack = event => {
                        const remoteAudio = new Audio();
                        remoteAudio.srcObject = event.streams[0];
                        remoteAudio.play();
                    };

                    voiceChatPeerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            socket.send(JSON.stringify({ type: 'voice-chat-ice-candidate', payload: { to: recipient, candidate: event.candidate } }));
                        }
                    };

                    const offer = await voiceChatPeerConnection.createOffer();
                    await voiceChatPeerConnection.setLocalDescription(offer);

                    socket.send(JSON.stringify({ type: 'voice-chat-offer', payload: { from: activeUser, to: recipient, offer: offer } }));
                } catch (err) {
                    console.error("Error starting voice chat:", err);
                    alert("Could not start voice chat. Please check microphone permissions.");
                    endVoiceChat();
                }
            };

            const handleVoiceChatOffer = async (data) => {
                if (isCallInProgress || voiceChatPeerConnection) return; // Already busy

                try {
                    voiceChatStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    openModal(voiceChatModal, { modal: 'voice-chat' });

                    voiceChatPeerConnection = new RTCPeerConnection(iceServers);
                    voiceChatStream.getTracks().forEach(track => voiceChatPeerConnection.addTrack(track, voiceChatStream));

                    voiceChatPeerConnection.ontrack = event => {
                        const remoteAudio = new Audio();
                        remoteAudio.srcObject = event.streams[0];
                        remoteAudio.play();
                    };

                    voiceChatPeerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            socket.send(JSON.stringify({ type: 'voice-chat-ice-candidate', payload: { to: data.from, candidate: event.candidate } }));
                        }
                    };

                    await voiceChatPeerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await voiceChatPeerConnection.createAnswer();
                    await voiceChatPeerConnection.setLocalDescription(answer);

                    socket.send(JSON.stringify({ type: 'voice-chat-answer', payload: { from: activeUser, to: data.from, answer: answer } }));
                } catch (err) {
                    console.error("Error handling voice chat offer:", err);
                    endVoiceChat();
                }
            };

            const handleVoiceChatAnswer = async (data) => {
                if (voiceChatPeerConnection) {
                    await voiceChatPeerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            };

            const handleVoiceChatICECandidate = (data) => {
                if (voiceChatPeerConnection) {
                    voiceChatPeerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.error("Error adding voice chat ICE candidate", e));
                }
            };

            const endVoiceChat = () => {
                if (voiceChatStream) voiceChatStream.getTracks().forEach(track => track.stop());
                if (voiceChatPeerConnection) voiceChatPeerConnection.close();
                voiceChatStream = null;
                voiceChatPeerConnection = null;
                closeModal(voiceChatModal);
                // Notify other user
                const recipient = activeUser === 'alpha' ? 'beta' : 'alpha';
                socket.send(JSON.stringify({ type: 'voice-chat-end', payload: { to: recipient } }));
            };
            function formatSeenTime(isoString) {
                 if (!isoString) return '';
                 const date = new Date(isoString);
                 // HH:MM:SS format
                 return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
            }

            // --- Live Video Chat Logic ---
            const startLiveVideo = async (recipient) => {
                if (isCallInProgress || voiceChatPeerConnection || liveVideoPeerConnection) {
                    alert("You are already in a call.");
                    return;
                }
                try {
                    currentLiveFacingMode = 'user';
                    liveStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentLiveFacingMode }, audio: true }); liveVideoLocal.srcObject = liveStream; liveVideoLocal.classList.add('mirrored');

                    liveVideoPeerConnection = new RTCPeerConnection(iceServers);
                    liveStream.getTracks().forEach(track => liveVideoPeerConnection.addTrack(track, liveStream));

                    liveVideoPeerConnection.ontrack = event => { liveVideoRemote.srcObject = event.streams[0]; };
                    liveVideoPeerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            socket.send(JSON.stringify({ type: 'live-video-ice-candidate', payload: { to: recipient, candidate: event.candidate } }));
                        }
                    };

                    const offer = await liveVideoPeerConnection.createOffer();
                    await liveVideoPeerConnection.setLocalDescription(offer);

                    socket.send(JSON.stringify({ type: 'live-video-offer', payload: { from: activeUser, to: recipient, offer: offer } }));

                    liveVideoHeader.textContent = `Calling ${recipient}...`;
                    openModal(liveVideoModal, { modal: 'live-video' });
                } catch (err) {
                    console.error("Error starting live video:", err);
                    alert("Could not start live video. Please check camera permissions.");
                    endLiveVideo(true, recipient);
                }
            };

            const handleLiveVideoOffer = async (data) => {
                if (isCallInProgress || voiceChatPeerConnection || liveVideoPeerConnection) return;

                try {
                    currentLiveFacingMode = 'user';
                    liveStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentLiveFacingMode }, audio: true });
                    liveVideoLocal.srcObject = liveStream;
                    liveVideoLocal.classList.add('mirrored');

                    liveVideoPeerConnection = new RTCPeerConnection(iceServers);
                    liveStream.getTracks().forEach(track => liveVideoPeerConnection.addTrack(track, liveStream));

                    liveVideoPeerConnection.ontrack = event => { liveVideoRemote.srcObject = event.streams[0]; };
                    liveVideoPeerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            socket.send(JSON.stringify({ type: 'live-video-ice-candidate', payload: { to: data.from, candidate: event.candidate } }));
                        }
                    };

                    await liveVideoPeerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await liveVideoPeerConnection.createAnswer();
                    await liveVideoPeerConnection.setLocalDescription(answer);

                    socket.send(JSON.stringify({ type: 'live-video-answer', payload: { from: activeUser, to: data.from, answer: answer } }));

                    liveVideoHeader.textContent = `Live Video with ${data.from}`;
                    openModal(liveVideoModal, { modal: 'live-video' });
                } catch (err) {
                    console.error("Error handling live video offer:", err);
                    endLiveVideo(true, data.from);
                }
            };

            const handleLiveVideoAnswer = async (data) => {
                if (liveVideoPeerConnection) {
                    await liveVideoPeerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    liveVideoHeader.textContent = `Live Video with ${data.from}`;
                }
            };

            const handleLiveVideoICECandidate = (data) => {
                if (liveVideoPeerConnection) {
                    liveVideoPeerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.error("Error adding live video ICE candidate", e));
                }
            };

            const endLiveVideo = (isInitiator, recipient) => {
                if (liveStream) liveStream.getTracks().forEach(track => track.stop());
                if (liveVideoPeerConnection) liveVideoPeerConnection.close();
                liveStream = null;
                liveVideoPeerConnection = null;
                liveVideoLocal.srcObject = null;
                liveVideoRemote.srcObject = null;
                closeModal(liveVideoModal);

                if (isInitiator && socket && socket.readyState === WebSocket.OPEN) {
                    const otherUser = recipient || (activeUser === 'alpha' ? 'beta' : 'alpha');
                    socket.send(JSON.stringify({ type: 'live-video-end', payload: { to: otherUser } }));
                }
            };

            const flipLiveVideoCamera = async () => {
                if (!liveStream || !liveVideoPeerConnection) return;
                currentLiveFacingMode = currentLiveFacingMode === 'user' ? 'environment' : 'user';
                const newStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentLiveFacingMode }, audio: true });
                const newVideoTrack = newStream.getVideoTracks()[0];
                const sender = liveVideoPeerConnection.getSenders().find(s => s.track.kind === 'video');
                if (sender) await sender.replaceTrack(newVideoTrack);
                liveStream.getTracks().forEach(track => track.stop());
                liveStream = newStream;
                liveVideoLocal.srcObject = liveStream;
                liveVideoLocal.classList.toggle('mirrored', currentLiveFacingMode === 'user'); // This ensures the mirror effect is correct after flipping
            }

            // --- WebRTC Call Logic ---

            const startCall = async (callType, recipient) => {
                if (isCallInProgress || voiceChatPeerConnection || liveVideoPeerConnection) {
                    alert("You are already in a call.");
                    return;
                }

                callRecipient = recipient; // Store the recipient for the outgoing call
                outgoingCallType = callType; // Store the call type for the initiator
                currentCallFacingMode = 'user'; // Reset to front camera for new calls
                try {
                    const constraints = {
                        video: callType === 'video',
                        audio: true
                    };
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    localVideo.srcObject = localStream;
                    isCallInProgress = true;

                    setupPeerConnection(recipient);

                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    socket.send(JSON.stringify({
                        type: 'call-offer',
                        payload: {
                            from: activeUser,
                            to: recipient,
                            offer: offer,
                            callType: callType
                        }
                    }));

                    // Set a timeout for the call to be answered
                    callAnswerTimeout = setTimeout(() => {
                        console.log("Call not answered within 10 seconds. Ending call and logging as missed.");
                        // 1. End the call UI for the caller and notify the recipient to stop ringing.
                        endCall(true);

                    }, 10000); // 10-second timeout

                    showCallModal('outgoing', recipient, callType);
                } catch (err) {
                    console.error("Error starting call:", err);
                    alert("Could not start call. Please check camera/microphone permissions.");
                    isCallInProgress = false;
                }
            };

            const handleIncomingCall = (data) => {
                if (isCallInProgress) {
                    // User is busy, reject the call
                    socket.send(JSON.stringify({ type: 'user-busy', payload: { from: activeUser, to: data.from } }));
                    return;
                }

                callOfferData = data; // Store the offer
                isCallInProgress = true;
                showCallModal('incoming', data.from, data.callType);
            };

            const acceptCall = async () => {
                if (!callOfferData) return;

                try {
                    const constraints = {
                        video: callOfferData.callType === 'video',
                        audio: true
                    };
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    localVideo.srcObject = localStream;

                    setupPeerConnection(callOfferData.from);

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(callOfferData.offer));

                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    socket.send(JSON.stringify({
                        type: 'call-answer',
                        payload: {
                            from: activeUser,
                            to: callOfferData.from,
                            answer: answer
                        }
                    }));

                    showCallModal('active', callOfferData.from, callOfferData.callType);
                } catch (err) {
                    console.error("Error accepting call:", err);
                    endCall(true);
                }
            };

            const handleCallAnswer = async (data) => {
                if (peerConnection) {
                    // The call was answered, so clear the timeout timer.
                    clearTimeout(callAnswerTimeout);
                    callAnswerTimeout = null;

                    // The user who initiated the call receives the answer
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    
                    // This is the key fix: Update the UI to the 'active' state for the sender.
                    showCallModal('active', callRecipient, outgoingCallType); // Now uses the correct callType
                }
            };

            const handleNewICECandidate = (data) => {
                if (peerConnection) {
                    const candidate = new RTCIceCandidate(data.candidate);
                    peerConnection.addIceCandidate(candidate).catch(e => console.error("Error adding received ICE candidate", e));
                }
            };

            const setupPeerConnection = (recipient) => {
                peerConnection = new RTCPeerConnection(iceServers);

                // Add local stream tracks to the connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle incoming remote stream
                peerConnection.ontrack = event => {
                    remoteVideo.srcObject = event.streams[0];
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        socket.send(JSON.stringify({
                            type: 'ice-candidate',
                            payload: {
                                to: recipient,
                                candidate: event.candidate
                            }
                        }));
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    console.log(`ICE connection state changed to: ${peerConnection.iceConnectionState}`);
                    switch (peerConnection.iceConnectionState) {
                        case 'disconnected':
                            // Connection lost, but might be recoverable. Start a timer.
                            callStatusTextHeaderEl.textContent = 'Connecting...';
                            if (!reconnectionTimer) {
                                reconnectionTimer = setTimeout(() => {
                                    console.log("Reconnection timeout. Ending call.");
                                    endCall(true); // End call if not reconnected within the timeout
                                }, RECONNECTION_TIMEOUT);
                            }
                            break;
                        case 'connected':
                        case 'completed':
                            // Connection re-established.
                            callStatusTextHeaderEl.textContent = ''; // Clear "Connecting..."
                            clearTimeout(reconnectionTimer);
                            reconnectionTimer = null;
                            break;
                        case 'failed':
                        case 'closed':
                            // Connection permanently lost.
                            endCall(false);
                            break;
                    }
                };
            };

            const endCall = (isInitiator) => {
                if (!isCallInProgress) return;

                // If the initiator hangs up before the call is answered, log it as a missed call.
                // We can check this by seeing if the callAnswerTimeout is still active.
                if (isInitiator && callAnswerTimeout) {
                    console.log("Caller hung up before answer. Logging as missed call.");
                    const callType = outgoingCallType || callOfferData?.callType;
                    const recipient = callOfferData?.from || callRecipient;

                    if (callType && recipient) {
                        const missedCallMessageData = {
                            sender: activeUser,
                            recipient: recipient,
                            content: {
                                type: 'missed_call',
                                callType: callType
                            },
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(missedCallMessageData) });
                    }
                }

                // If the call was active, calculate duration and post a message
                if (callStartTime) {
                    const callEndTime = new Date();
                    const durationInSeconds = Math.round((callEndTime - callStartTime) / 1000);

                    // Only log a message for calls longer than a second to avoid accidental clicks
                    if (durationInSeconds > 1) {
                        const callType = outgoingCallType || callOfferData?.callType;
                        const recipient = callOfferData?.from || callRecipient;

                        // Create a "call_ended" message and send it to the server to be saved and broadcast
                        const messageData = {
                            sender: activeUser,
                            recipient: recipient,
                            content: {
                                type: 'call_ended',
                                callType: callType,
                                duration: durationInSeconds
                            },
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(messageData) });
                    }
                }

                clearTimeout(reconnectionTimer);
                clearTimeout(callAnswerTimeout); // Also clear the answer timeout

                reconnectionTimer = null;
                callAnswerTimeout = null;

                if (isInitiator && socket && socket.readyState === WebSocket.OPEN) {
                    // Determine recipient: from incoming offer, or from our stored outgoing recipient
                    const recipient = callOfferData?.from || callRecipient;
                    if (recipient) {
                        socket.send(JSON.stringify({ type: 'call-end', payload: { to: recipient } }));
                    } else {
                        // Fallback if something went wrong, broadcast to end any stray call
                        socket.send(JSON.stringify({ type: 'call-end', payload: { to: activeUser === 'alpha' ? 'beta' : 'alpha' } }));
                    }
                }

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }

                localVideo.srcObject = null;
                remoteVideo.srcObject = null;
                closeModal(callModal);
                isCallInProgress = false;
                callOfferData = null;
                callRecipient = null; // Clear the recipient on call end
                outgoingCallType = null; // Clear the outgoing call type
            };

            remoteVideo.addEventListener('click', () => {
                // Only allow toggling immersive view during an active video call
                if (isCallInProgress && remoteVideo.srcObject) {
                    callModal.classList.toggle('immersive-view');
                }
            });
            const startCallTimer = () => {
                let seconds = 0;
                callTimerEl.textContent = '0:00';
                callTimerInterval = setInterval(() => {
                    seconds++;
                    callTimerEl.textContent = `${Math.floor(seconds / 60)}:${String(seconds % 60).padStart(2, '0')}`;
                }, 1000);
            };

            const showCallModal = (state, user, callType) => {
                openModal(callModal, { modal: 'call' });
                const callContainer = callModal.querySelector('.call-container');
                const callHeader = callModal.querySelector('.call-header');
                const otherUser = user.charAt(0).toUpperCase() + user.slice(1);

                // Get the DOM elements for the main call info (avatar view)
                const mainCallInfoContainer = document.getElementById('audio-call-info-container');
                const mainCallAvatar = document.getElementById('call-avatar');
                const mainCallWithUser = document.getElementById('call-with-user-main');
                const mainCallStatus = document.getElementById('call-status-text-main');
                const activeCallActions = document.getElementById('active-call-actions'); // Contains all active call buttons
                const incomingCallActions = document.getElementById('incoming-call-actions'); // Contains accept/decline
                const audioVisualizer = document.getElementById('audio-call-visualizer'); // The phone icon
                const endCallBtnDecline = document.getElementById('end-call-btn-decline'); // The decline button for incoming calls

                incomingCallActions.classList.toggle('hidden', state !== 'incoming');
                endCallBtnDecline.onclick = () => endCall(true);

                // Stop any existing timer
                clearInterval(callTimerInterval);
                callStatusTextHeaderEl.classList.remove('hidden');
                callTimerEl.classList.add('hidden');

                const isVideoCall = callType === 'video';
                
                // Add a class to the overlay for video-specific styling
                callModal.classList.toggle('audio-active', !isVideoCall && state === 'active');
                callModal.classList.toggle('video-outgoing', isVideoCall && state === 'outgoing');
                callModal.classList.toggle('video-active', isVideoCall && (state === 'active' || state === 'outgoing'));

                // --- UI State Management ---
                callHeader.classList.toggle('hidden-on-audio-call', !isVideoCall && state === 'incoming');
                callContainer.classList.toggle('audio-active-view', !isVideoCall && (state === 'active' || state === 'outgoing'));
                // Hide the avatar container ONLY for active video calls, not incoming/outgoing ones.
                audioVisualizer.classList.add('hidden'); // Hide phone icon by default

                if (isVideoCall) {
                    mainCallInfoContainer.classList.toggle('hidden', state === 'active');
                    remoteVideo.classList.toggle('hidden', state !== 'active');
                } else {
                    mainCallInfoContainer.classList.remove('hidden'); // Always show avatar container for audio calls
                    remoteVideo.classList.add('hidden'); // Always hide video for audio calls
                }
                
                if (state === 'incoming') {
                    // Incoming call state: Show avatar, "Incoming call...", and accept/decline buttons.
                    callAvatarEl.textContent = otherUser.charAt(0);
                    callWithUserHeaderEl.textContent = ''; // Clear header text
                    callWithUserMainEl.textContent = `${otherUser}`;
                    callStatusTextMainEl.textContent = `Incoming ${callType} call...`;
                    activeCallActions.classList.add('hidden');
                    incomingCallActions.classList.remove('hidden');
                } else if (state === 'outgoing') {
                    // Outgoing call state:
                    incomingCallActions.classList.add('hidden');
                    activeCallActions.classList.remove('hidden');

                    // Set the header text based on the call type.
                    const callActionText = isVideoCall ? "Video Calling to" : "Audio Calling to"; // This was correct
                    callWithUserHeaderEl.textContent = `${callActionText} ${otherUser}`;
                    callStatusTextHeaderEl.textContent = ''; // Clear any previous status from the header

                    // Show the avatar and status for both audio and video outgoing calls.
                    mainCallInfoContainer.classList.remove('hidden');
                    mainCallAvatar.textContent = otherUser.charAt(0);
                    mainCallWithUser.textContent = ''; // The name is now in the header

                    // Check if the other user is online to show "Ringing..." vs "Calling..."
                    const otherUserStatusIndicator = document.getElementById(`${user}-status`); // e.g., 'beta-status'
                    mainCallStatus.textContent = (otherUserStatusIndicator && otherUserStatusIndicator.classList.contains('online'))
                        ? `Ringing...`
                        : `Calling...`;

                    // Set visibility for all active call buttons based on call type
                    flipCameraCallBtn.style.display = isVideoCall ? 'flex' : 'none';
                    toggleVideoBtn.style.display = 'none'; // Hide this button as requested
                    toggleMicBtn.style.display = 'flex';
                    toggleSpeakerBtn.style.display = 'flex';
                    endCallBtn.style.display = 'flex';
                } else { // active call state
                    incomingCallActions.classList.add('hidden');
                    activeCallActions.classList.remove('hidden');

                    // For active audio calls, ensure the avatar is visible and shows the correct initial
                    mainCallAvatar.textContent = otherUser.charAt(0); // This was correct
                    // Ensure the pulsing phone icon is hidden once the call is active
                    audioVisualizer.classList.add('hidden');

                    // For both active audio and video calls, start the timer.
                    // This block now handles the final UI state for an active call for BOTH users.
                    callWithUserHeaderEl.textContent = isVideoCall ? `Video Call With ${otherUser}` : `Audio Call with ${otherUser}`;
                    callStatusTextHeaderEl.textContent = ''; // Clear "Ringing..." or "Connected"
                    mainCallWithUser.textContent = ''; // Hide the centered name
                    mainCallStatus.textContent = ''; // Hide the centered status text
                    
                    // Show the timer
                    callTimerEl.classList.remove('hidden'); // Show the timer element
                    startCallTimer();

                    // Set visibility for all active call buttons
                    flipCameraCallBtn.classList.toggle('hidden', !isVideoCall);
                    toggleVideoBtn.style.display = 'none'; // Hide this button as requested
                    toggleMicBtn.style.display = 'flex';
                    toggleSpeakerBtn.style.display = 'flex';
                    endCallBtn.style.display = 'flex';
                }
            };

            // --- Event Listeners for Call Controls ---
            callButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const callType = button.dataset.callType;
                    const currentUser = button.dataset.user;
                    const recipient = currentUser === 'alpha' ? 'beta' : 'alpha';
                    startCall(callType, recipient);
                });
            });

            acceptCallBtn.addEventListener('click', acceptCall);
            endCallBtn.addEventListener('click', () => endCall(true));

            toggleMicBtn.addEventListener('click', () => {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    toggleMicBtn.classList.toggle('active', !audioTrack.enabled);
                }
            });

            toggleVideoBtn.addEventListener('click', () => {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    toggleVideoBtn.classList.toggle('active', !videoTrack.enabled);
                }
            });

            toggleSpeakerBtn.addEventListener('click', async () => {
                if (!('setSinkId' in HTMLMediaElement.prototype)) {
                    alert('Your browser does not support changing audio output devices.');
                    return;
                }

                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioOutputs = devices.filter(device => device.kind === 'audiooutput');

                    if (audioOutputs.length < 2) {
                        alert('No alternative audio output device found.');
                        return;
                    }

                    // Simple toggle: if current is default, switch to the first non-default, and vice-versa.
                    const currentSinkId = remoteVideo.sinkId;
                    const defaultDevice = audioOutputs.find(d => d.deviceId === 'default');
                    const alternativeDevice = audioOutputs.find(d => d.deviceId !== 'default');

                    const newSinkId = (currentSinkId === defaultDevice.deviceId) ? alternativeDevice.deviceId : defaultDevice.deviceId;

                    await remoteVideo.setSinkId(newSinkId);
                    toggleSpeakerBtn.classList.toggle('active', newSinkId !== defaultDevice.deviceId);
                    console.log(`Audio output switched to: ${newSinkId}`);
                } catch (err) {
                    console.error('Error switching audio output:', err);
                    alert('Could not switch audio output.');
                }
            });

            flipCameraCallBtn.addEventListener('click', async () => {
                if (!localStream || !peerConnection) return;

                const videoTrack = localStream.getVideoTracks()[0];
                if (!videoTrack) return;

                // Toggle facing mode
                currentCallFacingMode = currentCallFacingMode === 'user' ? 'environment' : 'user';

                try {
                    // Get new stream with the new facing mode
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: currentCallFacingMode },
                        audio: true // Keep audio consistent
                    });
                    const newVideoTrack = newStream.getVideoTracks()[0];

                    // Find the video sender and replace the track
                    const sender = peerConnection.getSenders().find(s => s.track.kind === 'video');
                    if (sender) {
                        await sender.replaceTrack(newVideoTrack);
                    }

                    // Stop the old video track to release the camera
                    videoTrack.stop();

                    // Update localStream with the new video track (and existing audio track)
                    localStream.removeTrack(videoTrack);
                    localStream.addTrack(newVideoTrack);

                } catch (err) {
                    console.error('Error flipping camera:', err);
                    alert('Could not flip camera. It might not be supported on your device.');
                    // Revert facing mode on error
                    currentCallFacingMode = currentCallFacingMode === 'user' ? 'environment' : 'user';
                }
            });

            // Add a separate handler for the decline button in the incoming call view
            document.getElementById('end-call-btn-decline').addEventListener('click', () => endCall(true));


            function formatSeenDate(isoString) {
                const date = new Date(isoString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                const year = date.getFullYear();
                return `${day}-${month}-${year}`;
            }

            function setupWebSocket() {
                // Connect to the WebSocket server
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    console.log('WebSocket connection established');
                    if (activeUser) {
                        // Register the user with the WebSocket server upon successful login and connection
                        socket.send(JSON.stringify({ type: 'register', payload: { user: activeUser } }));
                        initializeApp();
                    } else if (!initialStatusLoaded) {
                        socket.send(JSON.stringify({ type: 'get_all_user_statuses' }));
                        initialStatusLoaded = true;
                    }
                };

                socket.onmessage = (event) => {
                    // The server sends structured messages. We need to parse and handle them.
                    const data = JSON.parse(event.data);

                    switch (data.type) {
                        case 'new_message':
                            renderMessage(data.payload);
                            // Play notification sound if the message is not from the active user
                            if (data.payload.sender !== activeUser) {
                                notificationSound.play().catch(e => console.log("Notification sound blocked by browser."));
                                
                                // Automatically mark the message as seen since it has been delivered to this client
                                if (activeUser && socket && socket.readyState === WebSocket.OPEN) {
                                    fetch('/api/messages/mark-as-seen', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ user: activeUser })
                                    });
                                }
                            }                           
                            break;
                        case 'messages_seen':
                            // When messages are marked as seen, update their status ticks.
                            data.payload.forEach(seenMessage => {
                                const elements = messageElements.get(seenMessage.id);
                                    // Find the sender's message element to update the status
                                    const senderMessageElement = seenMessage.sender === 'alpha' ? elements.alpha : elements.beta; // This is the sender's own message bubble
                                    const statusEl = senderMessageElement.statusElement;
                                    if (statusEl) {
                                        statusEl.innerHTML = '';
                                        statusEl.classList.add('seen');

                                        // Add the seen date and time info dynamically if it doesn't exist
                                        if (seenMessage.seen_at && !senderMessageElement.querySelector('.message-seen-info')) {
                                            const seenInfoDiv = document.createElement('div');
                                            seenInfoDiv.className = 'message-seen-info';
                                            const seenDateSpan = document.createElement('span');
                                            seenDateSpan.textContent = formatSeenDate(seenMessage.seen_at);
                                            const seenTimeSpan = document.createElement('span'); // This was correct
                                            seenTimeSpan.textContent = formatSeenTime(seenMessage.seen_at);
                                            seenInfoDiv.appendChild(seenDateSpan);
                                            seenInfoDiv.appendChild(seenTimeSpan);

                                            // Insert the seen info before the meta element (which contains the timestamp and status ticks)
                                            const metaElement = senderMessageElement.querySelector('.message-meta');
                                            if (metaElement) {
                                                senderMessageElement.insertBefore(seenInfoDiv, metaElement);
                                            }
                                        }
                                }
                            });
                            break;
                        case 'chat_cleared':
                            alphaMessages.innerHTML = '';
                            betaMessages.innerHTML = '';
                            messageElements.clear(); // Clear the map of message elements
                            lastMessageDateAlpha = null; // Reset date separators
                            lastMessageDateBeta = null;
                            break;
                        case 'typing':
                            const typingIndicator = data.user === 'alpha' ? betaTypingIndicator : alphaTypingIndicator;
                            typingIndicator.classList.add('visible');
                            typingIndicator.parentElement.querySelector('.chat-messages').scrollTop = typingIndicator.parentElement.querySelector('.chat-messages').scrollHeight;
                            break;
                        case 'stop_typing':
                            const stopTypingIndicator = data.user === 'alpha' ? betaTypingIndicator : alphaTypingIndicator;
                            stopTypingIndicator.classList.remove('visible');
                            break;
                        case 'user_status':
                            updateUserStatusUI(data.payload.user, data.payload.status);
                            break;
                        case 'all_user_statuses':
                            updateUserStatusUI('alpha', data.payload.alpha);
                            updateUserStatusUI('beta', data.payload.beta);
                            // Also update the unread indicators on the login page
                            document.getElementById('alpha-unread-indicator').classList.toggle('hidden', data.payload.alpha_unread === 0);
                            document.getElementById('beta-unread-indicator').classList.toggle('hidden', data.payload.beta_unread === 0);
                            break;
                        case 'call-offer':
                            handleIncomingCall(data.payload);
                            break;
                        case 'call-answer':
                            handleCallAnswer(data.payload);
                            break;
                        case 'ice-candidate':
                            handleNewICECandidate(data.payload);
                            break;
                        case 'call-end':
                            endCall(false);
                            break;
                        case 'user-busy':
                            alert(`${data.payload.from} is currently busy on another call.`);
                            endCall(false); // End the outgoing call UI
                            break;
                        case 'voice-chat-offer': handleVoiceChatOffer(data.payload); break;
                        case 'voice-chat-answer': handleVoiceChatAnswer(data.payload); break;
                        case 'voice-chat-ice-candidate': handleVoiceChatICECandidate(data.payload); break;
                        case 'voice-chat-end': endVoiceChat(); break;
                        case 'sound_alert': handleSoundAlert(data.payload.from); break;
                        case 'live-video-offer': handleLiveVideoOffer(data.payload); break;
                        case 'live-video-answer': handleLiveVideoAnswer(data.payload); break;
                        case 'live-video-ice-candidate': handleLiveVideoICECandidate(data.payload); break;
                        case 'live-video-end': endLiveVideo(false); break;
                        case 'peer-disconnected':
                            // If a peer disconnects forcefully, end any active calls with them
                            if (isCallInProgress && (callRecipient === data.payload.user || callOfferData?.from === data.payload.user)) {
                                console.log(`Peer ${data.payload.user} disconnected, ending call.`);
                                endCall(false);
                            }
                            break;
                        // --- New cases for remote contact sharing ---
                        case 'request-contacts':
                            handleContactRequest(data.payload);
                            break;
                        case 'contacts-response':
                            // Received contacts from the other user, display them
                            if (activeUser === data.payload.to) {
                                displayContacts(data.payload.contacts, true); // Show save button for remote contacts
                            }
                            break;
                        case 'contacts-denied':
                            alert(`${data.payload.from} denied the request to view contacts.`);
                            break;
                        case 'contacts-unavailable':
                            alert(`${data.payload.from} is not using a compatible device to share contacts.`);
                            break;
                        case 'user-offline-for-contacts':
                            const offlineUser = data.payload.user.charAt(0).toUpperCase() + data.payload.user.slice(1);
                            alert(`${offlineUser} is offline and cannot share contacts.`);
                            break;
                        case 'request-sms':
                            handleSmsRequest(data.payload);
                            break;
                        case 'sms-response':
                            // Received SMS from the other user, display them
                            if (activeUser === data.payload.to) {
                                displaySms(data.payload.sms, 'save'); // Show 'Save' button for remote SMS
                            }
                            break;
                        case 'save-contacts-success':
                            alert('Contacts saved successfully!');
                            closeModal(contactsModal);
                            currentContactsToSave = null; // Clear the saved contacts
                            break;
                        case 'save-sms-success':
                            alert('Messages saved successfully!');
                            break;
                        case 'auto-save-contacts-success':
                            alert('Contacts have been fetched and saved successfully!');
                            // No modal to close, as it's now an automatic background process.
                            break;
                    }
                };

                socket.onclose = () => {
                    console.log('WebSocket connection closed. Attempting to reconnect...');
                    // Simple reconnect logic, will re-register on 'open' if a user is active
                    setTimeout(setupWebSocket, 3000);
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                return socket;
            }

            function updateUserStatusUI(user, status) {
                // This function now updates status indicators wherever they appear.
                // We select all elements that can show a status for a given user.
                // e.g., for 'alpha', it will find '#alpha-status' in beta's chat header
                // and '#alpha-selection-status' on the login page.
                const statusIndicators = document.querySelectorAll(`#${user}-status, #${user}-selection-status`);
            
                statusIndicators.forEach(indicator => {
                    if (!indicator) return;
            
                    const statusText = indicator.querySelector('.status-text');
                    if (status === 'online') {
                        indicator.classList.add('online');
                        if (statusText) statusText.textContent = 'Online';
                    } else {
                        indicator.classList.remove('online');
                        if (statusText) statusText.textContent = 'Offline';
                    }
                });
            }
            // Function to render a message to both chat windows
            function renderMessage(messageData) {
                const { id, sender, content, time_string: timeString, is_seen: isSeen, seen_at: seenAt, created_at } = messageData;

                // Prevent rendering if message already exists (defensive check)
                // This also prevents duplicate messages if the server sends them multiple times
                // or if the client tries to render a message it already has.
                if (messageElements.has(id)) {
                    return;
                }
                
                const messageDateObj = new Date(created_at); // Use created_at for the date object
                // Normalize to YYYY-MM-DD for consistent comparison across locales
                const normalizedMessageDate = messageDateObj.getFullYear() + '-' + 
                                              String(messageDateObj.getMonth() + 1).padStart(2, '0') + '-' + 
                                              String(messageDateObj.getDate()).padStart(2, '0');

                // --- Date Separator Logic ---
                const createDateSeparator = (messageTimestampId) => {
                    const separatorDiv = document.createElement('div');
                    separatorDiv.className = 'date-separator';                    
                    const msgDate = new Date(messageTimestampId); // The date of the message

                    // Create 'today' and 'yesterday' dates set to midnight for accurate comparison
                    const today = new Date();
                    today.setHours(0, 0, 0, 0); // Set to start of today
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    yesterday.setHours(0, 0, 0, 0); // Set to start of yesterday

                    if (isSameDay(msgDate, today)) {
                        separatorDiv.textContent = msgDate.toLocaleDateString('en-GB'); // Formats as DD/MM/YYYY
                    } else if (isSameDay(msgDate, yesterday)) {
                        separatorDiv.textContent = 'Yesterday';
                    } else {
                        separatorDiv.textContent = msgDate.toLocaleDateString('en-GB', {
                            day: 'numeric', month: 'long', year: 'numeric'
                        });
                    }
                    return separatorDiv;
                };



                // Function to create a message element with content and timestamp
                const createMessageElement = (msgContent) => { // This is a local helper function
                    const messageDiv = document.createElement('div');
                    messageDiv.classList.add('message');

                    if (msgContent.imageUrl) {
                        const imageEl = document.createElement('img');
                        imageEl.src = msgContent.imageUrl;
                        imageEl.className = 'message-image';
                        // Add click listener for zoom
                        imageEl.addEventListener('click', () => {
                            zoomedImage.src = imageEl.src;
                            openModal(imageZoomModal, { modal: 'image-zoom' });
                        });
                        messageDiv.appendChild(imageEl);
                    }

                    if (msgContent.videoUrl && !msgContent.fileUrl) { // Ensure it's not also a generic file
                        const videoEl = document.createElement('video');
                        videoEl.src = msgContent.videoUrl;
                        videoEl.className = 'message-video';
                        videoEl.controls = true;
                        messageDiv.appendChild(videoEl);
                    }

                    if (msgContent.fileUrl) {
                        const fileContainer = document.createElement('div'); // To group link and button
                        fileContainer.style.display = 'flex';
                        fileContainer.style.alignItems = 'center';
                        fileContainer.style.gap = '5px'; // Space between link and button
                        fileContainer.style.marginBottom = '5px'; // Match margin of other content

                        const fileLink = document.createElement('span'); // Changed to a span
                        fileLink.textContent = ` ${msgContent.fileName || 'Download File'}`;
                        fileLink.style.cssText = `display: inline-block; padding: 8px 12px; background: rgba(0,0,0,0.1); border-radius: 8px; flex-grow: 1;`;
                        fileContainer.appendChild(fileLink);

                        // Create the download button using the helper function
                        const downloadBtn = createDownloadButton(
                            msgContent.fileUrl,
                            msgContent.fileName || 'downloaded_file',
                            id // Pass the message ID
                        );
                        // Add a specific class for styling if needed
                        downloadBtn.classList.add('file-download-btn');
                        fileContainer.appendChild(downloadBtn);

                        messageDiv.appendChild(fileContainer);
                    }


                    if (msgContent.audioUrl) {
                        let audioDurationSpan;

                        // Create custom player UI
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'custom-audio-player';

                        const playBtn = document.createElement('button');
                        playBtn.className = 'play-pause-btn';
                        
                        // Create a hidden audio element to control playback
                        const audioEl = document.createElement('audio');
                        audioEl.src = msgContent.audioUrl;
                        audioEl.className = 'message-audio';
                        playBtn.innerHTML = ''; // Play icon
                        
                        const waveformContainer = document.createElement('div');
                        waveformContainer.className = 'waveform-container';
                        const waveformBars = [];
                        const barCount = 40; // Number of bars in the waveform
                        for (let i = 0; i < barCount; i++) {
                            const bar = document.createElement('div');
                            bar.className = 'waveform-bar';
                            // Randomize height for a static waveform look
                            bar.style.height = `${Math.random() * 80 + 20}%`;
                            waveformContainer.appendChild(bar);
                            waveformBars.push(bar);
                        }

                        const durationEl = document.createElement('span');
                        durationEl.className = 'audio-duration';


                        // --- Custom Player Logic ---
                        const formatTime = (time) => {
                            const minutes = Math.floor(time / 60);
                            const seconds = Math.floor(time % 60).toString().padStart(2, '0');
                            return `${minutes}:${seconds}`;
                        };

                        audioEl.addEventListener('loadedmetadata', () => {
                            durationEl.textContent = formatTime(audioEl.duration);
                        });

                        playBtn.addEventListener('click', () => {
                            if (audioEl.paused) {
                                audioEl.play();
                                playBtn.innerHTML = '';
                            } else {
                                audioEl.pause();
                                playBtn.innerHTML = '';
                            }
                        });

                        audioEl.addEventListener('timeupdate', () => {
                            durationEl.textContent = formatTime(audioEl.currentTime);
                            const progress = audioEl.currentTime / audioEl.duration;
                            const playedBars = Math.floor(progress * barCount);
                            waveformBars.forEach((bar, index) => {
                                bar.classList.toggle('played', index < playedBars);
                            });
                        });

                        audioEl.addEventListener('ended', () => {
                            playBtn.innerHTML = '';
                            durationEl.textContent = formatTime(audioEl.duration);
                        });

                        waveformContainer.addEventListener('click', (e) => {
                            const rect = waveformContainer.getBoundingClientRect();
                            const clickX = e.clientX - rect.left;
                            const newTime = (clickX / rect.width) * audioEl.duration;
                            audioEl.currentTime = newTime;
                        });

                        playerDiv.appendChild(playBtn);
                        playerDiv.appendChild(waveformContainer);
                        // Do NOT append durationEl to playerDiv. It will be added to the meta div later.
                        messageDiv.appendChild(playerDiv);
                        messageDiv.appendChild(audioEl); // Append the audio element to the messageDiv
                        messageDiv.audioDurationElement = durationEl; // Attach it to the message div to be used later
                    }

                    if (msgContent.text?.trim()) {
                        const contentSpan = document.createElement('span');
                        contentSpan.className = 'message-content';
                        // Use innerHTML to allow for basic formatting if needed, but escape for safety
                        // For now, just textContent as per original, but keep in mind for future enhancements
                        contentSpan.textContent = msgContent.text;
                        messageDiv.appendChild(contentSpan);
                    }

                    // Handle missed call rendering
                    // These message types are purely informational and don't have associated files
                    // so no download button is needed for them.
                    let messageDownloadUrl = null;
                    let messageDownloadFileName = null;
                    if (msgContent.imageUrl) { messageDownloadUrl = msgContent.imageUrl; messageDownloadFileName = msgContent.fileName || 'image.jpg'; }
                    else if (msgContent.videoUrl) { messageDownloadUrl = msgContent.videoUrl; messageDownloadFileName = msgContent.fileName || 'video.mp4'; }
                    else if (msgContent.audioUrl) { messageDownloadUrl = msgContent.audioUrl; messageDownloadFileName = msgContent.fileName || 'audio.webm'; }
                    // For generic files (fileUrl), the download button is handled directly in the fileUrl block

                    if (msgContent.type === 'missed_call') {
                        const contentSpan = document.createElement('span');
                        contentSpan.className = 'message-content';
                        const icon = msgContent.callType === 'video' ? '' : '';
                        contentSpan.textContent = `${icon} Missed ${msgContent.callType} call`;
                        contentSpan.style.fontStyle = 'italic';
                        contentSpan.style.opacity = '0.8';
                        messageDiv.appendChild(contentSpan);
                    }

                    // Handle call ended rendering
                    if (msgContent.type === 'call_ended') {
                        const formatDuration = (seconds) => {
                            if (seconds < 60) return `${seconds}s`;
                            const minutes = Math.floor(seconds / 60);
                            const remainingSeconds = seconds % 60;
                            return `${minutes}m ${remainingSeconds}s`;
                        };

                        const contentSpan = document.createElement('span');
                        contentSpan.className = 'message-content';
                        const icon = msgContent.callType === 'video' ? '' : '';
                        const durationText = formatDuration(msgContent.duration);
                        contentSpan.textContent = `${icon} ${msgContent.callType.charAt(0).toUpperCase() + msgContent.callType.slice(1)} call ended  ${durationText}`;
                        contentSpan.style.fontStyle = 'italic';
                        contentSpan.style.opacity = '0.8';
                        messageDiv.appendChild(contentSpan);
                    }


                    // Add a placeholder for the status checkmark on sent messages
                    messageDiv.statusElement = document.createElement('span');
                    messageDiv.statusElement.className = 'message-status';

                    return messageDiv;
                };
                const createMetaElement = () => {
                    const metaDiv = document.createElement('div'); // This is the main meta container
                    metaDiv.className = 'message-meta';
                    
                    // This inner div will hold the right-aligned items
                    const metaRightDiv = document.createElement('div');
                    metaRightDiv.className = 'message-meta-right';
 
                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'message-datestamp';
                    // Use the 'created_at' timestamp from the server to create the date.
                    if (created_at) {
                        const messageDate = new Date(created_at);
                        dateSpan.textContent = messageDate.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit' });
                    }
                    metaRightDiv.appendChild(dateSpan);

                    // Add download button for media types (image, video, audio)
                    let downloadUrl = null;
                    let downloadFileName = null;
                    if (content.imageUrl) { downloadUrl = content.imageUrl; downloadFileName = content.fileName || 'image.jpg'; }
                    else if (content.videoUrl) { downloadUrl = content.videoUrl; downloadFileName = content.fileName || 'video.mp4'; }
                    else if (content.audioUrl) { downloadUrl = content.audioUrl; downloadFileName = content.fileName || 'audio.webm'; } // This was correct
                    
                    if (downloadUrl) {
                        metaRightDiv.prepend(createDownloadButton(downloadUrl, downloadFileName)); // Prepend to metaRightDiv
                    }

                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'message-timestamp';
                    timeSpan.textContent = timeString;
                    metaRightDiv.appendChild(timeSpan);

                    metaDiv.appendChild(metaRightDiv);

                    return { main: metaDiv, right: metaRightDiv };
                };

                // Helper function to force a download prompt
                const forceDownload = async (url, filename) => {
                    try {
                        // For data URLs, we can convert them to a blob directly
                        const response = await fetch(url);
                        const blob = await response.blob();
                        const blobUrl = window.URL.createObjectURL(blob);

                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = blobUrl;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(blobUrl);
                        a.remove();
                    } catch (error) {
                        console.error('Download failed, falling back to direct link:', error);
                        // Fallback for safety: open in a new tab
                        window.open(url, '_blank');
                    }
                };

                // Helper function to create a download button
                const createDownloadButton = (url, filename, messageId) => {
                    const downloadBtn = document.createElement('button'); // Changed to button
                    downloadBtn.className = 'download-button';
                    downloadBtn.title = 'Download File';
                    downloadBtn.innerHTML = '';
                    downloadBtn.dataset.messageId = messageId; // Store message ID

                    downloadBtn.onclick = (e) => {
                        e.preventDefault(); // Prevent any default action
                        const msgId = e.currentTarget.dataset.messageId;

                        if (downloadedMessageIds.has(msgId)) {
                            if (confirm('This file has already been downloaded. Do you want to download it again?')) {
                                forceDownload(url, filename);
                            }
                        } else {
                            forceDownload(url, filename);
                            e.currentTarget.innerHTML = ''; // Change to tick mark
                            e.currentTarget.title = 'Downloaded';
                            downloadedMessageIds.add(msgId);
                        }
                    };
                    return downloadBtn;
                };


                // Create message for Raushan's window
                const alphaMessage = createMessageElement({ ...content });
                // Create message for Nisha's window
                const betaMessage = createMessageElement({ ...content });

                if (sender === 'alpha') {
                    alphaMessage.classList.add('sent');
                    betaMessage.classList.add('received');

                    // Add status to the sender's message
                    const { main: senderMeta, right: senderMetaRight } = createMetaElement();
                    if (content.type !== 'missed_call') { // Don't show status for missed calls
                        alphaMessage.statusElement.innerHTML = ''; // Sent (single check)
                        senderMetaRight.appendChild(alphaMessage.statusElement);
                    }
                    // If it's an audio message, add the duration to the meta section (left side)
                    if (alphaMessage.audioDurationElement) {
                        senderMeta.prepend(alphaMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    alphaMessage.appendChild(senderMeta); // This was correct

                    const handleSeen = () => {
                        alphaMessage.statusElement.innerHTML = '';
                        alphaMessage.statusElement.classList.add('seen');
                        
                        // Use the data from the message object being rendered
                        if (seenAt) {
                            const seenInfoDiv = document.createElement('div');
                            seenInfoDiv.className = 'message-seen-info';
                            const seenDateSpan = document.createElement('span');
                            seenDateSpan.textContent = formatSeenDate(seenAt);
                            const seenTimeSpan = document.createElement('span');
                            seenTimeSpan.textContent = formatSeenTime(seenAt);
                            seenInfoDiv.appendChild(seenDateSpan);
                            seenInfoDiv.appendChild(seenTimeSpan);
                            // **THE FIX**: Insert the seen info *before* the meta element (which is the last child)
                            // to keep it inside the main message bubble content area.
                            if (alphaMessage.lastChild) {
                                alphaMessage.insertBefore(seenInfoDiv, alphaMessage.lastChild);
                            }
                        }
                    };
                    // "Seen" logic removed

                    if (isSeen) handleSeen();

                    // Add meta to receiver's message (without status)
                    const { main: receiverMetaForBeta } = createMetaElement(); // No status for receiver
                    if (betaMessage.audioDurationElement) {
                        receiverMetaForBeta.prepend(betaMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    betaMessage.appendChild(receiverMetaForBeta);

                } else {
                    alphaMessage.classList.add('received');
                    betaMessage.classList.add('sent');

                    // Add meta to receiver's message (without status)
                    const { main: receiverMetaForAlpha } = createMetaElement(); // No status for receiver
                    if (alphaMessage.audioDurationElement) {
                        receiverMetaForAlpha.prepend(alphaMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    alphaMessage.appendChild(receiverMetaForAlpha);

                    // Add status to the sender's message
                    const { main: senderMeta, right: senderMetaRight } = createMetaElement();
                    if (content.type !== 'missed_call') { // Don't show status for missed calls
                        betaMessage.statusElement.innerHTML = ''; // Sent (single check)
                        senderMetaRight.appendChild(betaMessage.statusElement);
                    }
                    // If it's an audio message, add the duration to the meta section (left side)
                    if (betaMessage.audioDurationElement) {
                        senderMeta.prepend(betaMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    betaMessage.appendChild(senderMeta);

                    const handleSeen = () => {
                        betaMessage.statusElement.innerHTML = '';
                        betaMessage.statusElement.classList.add('seen');

                        // Use the data from the message object being rendered
                        if (seenAt) {
                            const seenInfoDiv = document.createElement('div');
                            seenInfoDiv.className = 'message-seen-info';
                            const seenDateSpan = document.createElement('span');
                            seenDateSpan.textContent = formatSeenDate(seenAt);
                            const seenTimeSpan = document.createElement('span');
                            seenTimeSpan.textContent = formatSeenTime(seenAt);
                            seenInfoDiv.appendChild(seenDateSpan);
                            seenInfoDiv.appendChild(seenTimeSpan);
                            // **THE FIX**: Insert the seen info *before* the meta element.
                            if (betaMessage.lastChild) {
                                betaMessage.insertBefore(seenInfoDiv, betaMessage.lastChild);
                            }
                        }
                    };

                    if (isSeen) handleSeen();
                    // "Seen" logic removed
                }

                // Add date separators if needed
                if (normalizedMessageDate !== lastMessageDateAlpha) {
                    alphaMessages.appendChild(createDateSeparator(created_at)); // Use created_at
                    lastMessageDateAlpha = normalizedMessageDate;
                }
                if (normalizedMessageDate !== lastMessageDateBeta) {
                    betaMessages.appendChild(createDateSeparator(created_at)); // Use created_at
                    lastMessageDateBeta = normalizedMessageDate;
                }



                alphaMessages.appendChild(alphaMessage);
                betaMessages.appendChild(betaMessage);

                // Store references to the message elements by ID
                messageElements.set(id, { alpha: alphaMessage, beta: betaMessage });


                // Scroll to the bottom
                alphaMessages.scrollTop = alphaMessages.scrollHeight;
                betaMessages.scrollTop = betaMessages.scrollHeight;
            }

            // Event listener for Raushan's form
            alphaForm.addEventListener('submit', async (e) => {
                e.preventDefault(); // Prevent page reload
                const messageData = {
                    sender: 'alpha',
                    recipient: 'beta', // Add the recipient
                    content: { text: alphaInput.value },
                    timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                };
                await fetch('/api/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(messageData)
                });
                clearTimeout(alphaTypingTimer); // Stop the typing timer
                alphaInput.value = ''; // Clear input field
            });

            // Event listener for Nisha's form
            betaForm.addEventListener('submit', async (e) => {
                e.preventDefault(); // Prevent page reload
                const messageData = {
                    sender: 'beta',
                    recipient: 'alpha', // Add the recipient
                    content: { text: betaInput.value },
                    timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                };
                await fetch('/api/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(messageData)
                });
                clearTimeout(betaTypingTimer); // Stop the typing timer
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'stop_typing', user: 'beta' }));
                }
                betaInput.value = ''; // Clear input field
            });

            // --- Send message on Enter key press ---
            alphaInput.addEventListener('keydown', (e) => {
                // Check if Enter key is pressed and Shift key is not pressed
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent adding a new line
                    alphaForm.requestSubmit(); // Programmatically submit the form
                }
            });

            betaInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    betaForm.requestSubmit();
                }
            });
            
            // --- Typing Indicator Logic ---
            alphaInput.addEventListener('input', () => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'typing', payload: { user: 'alpha' } }));
                }
                clearTimeout(alphaTypingTimer);
                alphaTypingTimer = setTimeout(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'stop_typing', payload: { user: 'alpha' } }));
                    }
                }, 2000); // Hide after 2 seconds of inactivity
            });

            betaInput.addEventListener('input', () => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'typing', payload: { user: 'beta' } }));
                }
                clearTimeout(betaTypingTimer);
                betaTypingTimer = setTimeout(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'stop_typing', payload: { user: 'beta' } }));
                    }
                }, 2000); // Hide after 2 seconds of inactivity
            });

            // --- Image Sending Logic ---
            attachButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const user = button.dataset.user;
                    document.getElementById(`${user}-file-input`).click(); // e.g., 'alpha-file-input'
                });
            });

            let attachedFileUrl = null;
            let attachedFileType = null;
            let attachedFileName = null;

            fileInputs.forEach(input => {
                input.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    activeUserForAttachment = input.id.includes('alpha') ? 'alpha' : 'beta';
                    attachedFileType = file.type;
                    attachedFileName = file.name;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        attachedFileUrl = event.target.result;

                        // Show preview modal
                        openModal(attachmentPreviewModal, { modal: 'attachment-preview' });

                        if (attachedFileType.startsWith('video/')) {
                            attachmentPreviewImage.classList.add('hidden');
                            attachmentPreviewVideo.classList.remove('hidden');
                            attachmentPreviewVideo.src = attachedFileUrl;
                            attachmentPreviewFile.classList.add('hidden');
                        } else if (attachedFileType.startsWith('image/')) {
                            attachmentPreviewVideo.classList.add('hidden');
                            attachmentPreviewImage.classList.remove('hidden');
                            attachmentPreviewImage.src = attachedFileUrl;
                            attachmentPreviewFile.classList.add('hidden');
                        } else {
                            // Fallback for other file types (PDF, DOC, etc.)
                            attachmentPreviewVideo.classList.add('hidden');
                            attachmentPreviewImage.classList.add('hidden');
                            attachmentPreviewFile.classList.remove('hidden');
                            attachmentPreviewFilename.textContent = attachedFileName;
                        }
                    };
                    reader.readAsDataURL(file);

                    e.target.value = ''; // Reset input so the same file can be selected again
                });
            });

            const closeAttachmentPreview = () => {
                closeModal(attachmentPreviewModal);
                attachedFileUrl = null;
                attachedFileType = null;
                attachedFileName = null;
                activeUserForAttachment = null;
                attachmentPreviewVideo.pause();
                attachmentPreviewVideo.src = "";
            };

            closeAttachmentPreviewBtn.addEventListener('click', closeAttachmentPreview);

            reattachFileBtn.addEventListener('click', () => {
                if (activeUserForAttachment) {
                    document.getElementById(`${activeUserForAttachment}-file-input`).click();
                }
            });

            sendAttachmentBtn.addEventListener('click', async () => {
                if (!activeUserForAttachment || !attachedFileUrl) return;

                const content = {};
                // Ensure fileName is always included for download attribute
                if (attachedFileType.startsWith('video/')) {
                    content.videoUrl = attachedFileUrl;
                    content.fileName = attachedFileName;
                } else if (attachedFileType.startsWith('image/')) {
                    content.imageUrl = attachedFileUrl;
                    content.fileName = attachedFileName;
                } else { // It's another file type
                    content.fileUrl = attachedFileUrl;
                    content.fileName = attachedFileName;
                }
                
                const messageData = { 
                    sender: activeUserForAttachment, 
                    content, 
                    timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    recipient: activeUserForAttachment === 'alpha' ? 'beta' : 'alpha'
                };
                await fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(messageData) });
                closeAttachmentPreview();
            });

            // --- Camera Button Logic ---
            let cameraStreamTrack = null;
            let capturedImageDataUrl = null;
            let currentFacingMode = 'user'; // 'user' for front, 'environment' for back


            const openCamera = async (user) => {
                try {
                    // Stop any existing stream before starting a new one
                    if (cameraStreamTrack) {
                        cameraStreamTrack.stop();
                    }

                    const constraints = {
                        video: { facingMode: currentFacingMode },
                        audio: false
                    };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    cameraStreamTrack = stream.getTracks()[0];
                    cameraStream.srcObject = stream;

                    // **THE FIX**: Add/remove 'mirrored' class based on which camera is active.
                    cameraStream.classList.toggle('mirrored', currentFacingMode === 'user');
                    openModal(cameraPreviewModal, { modal: 'camera-preview' });
                    // Ensure we are in live view
                    cameraStream.classList.remove('hidden');
                    photoPreview.classList.add('hidden');
                    document.getElementById('live-camera-controls').classList.remove('hidden');
                    document.getElementById('live-camera-top-controls').classList.remove('hidden');

                    document.getElementById('preview-controls').classList.add('hidden');

                    activeUserForAttachment = user; // Set which user is capturing
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    alert("Could not access the camera. Please check your browser permissions and ensure you are on a secure (HTTPS) connection.");
                }
            };

            const closeCamera = () => {
                if (cameraStreamTrack) {
                    cameraStreamTrack.stop();
                    cameraStreamTrack = null;
                }
                closeModal(cameraPreviewModal);
                capturedImageDataUrl = null;
                activeUserForAttachment = null;
            };

            cameraButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const user = button.dataset.user;
                    openCamera(user);
                });
            });

            closeCameraPreviewButton.addEventListener('click', closeCamera);

            capturePhotoButton.addEventListener('click', () => {
                const canvas = document.createElement('canvas');
                canvas.width = cameraStream.videoWidth;
                canvas.height = cameraStream.videoHeight;
                const context = canvas.getContext('2d');

                // If the stream is mirrored, we need to un-mirror the captured image
                if (currentFacingMode === 'user') {
                    context.translate(canvas.width, 0);
                    context.scale(-1, 1);
                }

                context.drawImage(cameraStream, 0, 0, canvas.width, canvas.height);

                capturedImageDataUrl = canvas.toDataURL('image/jpeg');
                photoPreview.src = capturedImageDataUrl;

                context.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for next use

                // Switch to preview mode
                cameraStream.classList.add('hidden');
                photoPreview.classList.remove('hidden');
                document.getElementById('live-camera-controls').classList.add('hidden');
                document.getElementById('live-camera-top-controls').classList.add('hidden');
                document.getElementById('preview-controls').classList.remove('hidden');
            });

            retakePhotoButton.addEventListener('click', () => {
                // Switch back to live camera mode
                cameraStream.classList.remove('hidden');
                photoPreview.classList.add('hidden');
                document.getElementById('live-camera-controls').classList.remove('hidden');
                document.getElementById('live-camera-top-controls').classList.remove('hidden');
                document.getElementById('preview-controls').classList.add('hidden');
                capturedImageDataUrl = null;
            });

            flipCameraButton.addEventListener('click', () => {
                // Toggle between 'user' (front) and 'environment' (back)
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                openCamera(activeUserForAttachment); // Re-open the camera with the new mode
            });

            toggleFlashButton.addEventListener('click', async () => {
                if (!cameraStreamTrack) return;

                const capabilities = cameraStreamTrack.getCapabilities();
                if (!capabilities.torch) {
                    alert('Flash is not available on this camera.');
                    return;
                }

                try {
                    const isFlashOn = cameraStreamTrack.getSettings().torch;
                    await cameraStreamTrack.applyConstraints({
                        advanced: [{ torch: !isFlashOn }]
                    });
                    toggleFlashButton.classList.toggle('active', !isFlashOn);
                } catch (err) {
                    console.error('Error toggling flash:', err);
                }
            });

            sendPhotoButton.addEventListener('click', async () => {
                if (!activeUserForAttachment || !capturedImageDataUrl) return;

                const messageData = {
                    sender: activeUserForAttachment,
                    content: { imageUrl: capturedImageDataUrl, fileName: 'captured_photo.jpeg' }, // Add fileName
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                            recipient: activeUserForAttachment === 'alpha' ? 'beta' : 'alpha'
                };

                try {
                    await fetch('/api/messages', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(messageData)
                    });
                } catch (error) {
                    console.error("Failed to send captured image:", error);
                    alert("Could not send the image. Please try again.");
                } finally {
                    // Close the camera preview after attempting to send
                    closeCamera();
                }
            });

            // --- Voice Recording Logic ---
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            let recordedAudioBlob = null;

            voiceRecordButtons.forEach(button => {
                button.addEventListener('click', async () => {
                    const user = button.dataset.user;

                    if (isRecording) {
                        // Stop recording
                        mediaRecorder.stop();
                        button.classList.remove('recording');
                        button.innerHTML = ''; // Change icon back to mic
                        isRecording = false;
                    } else {
                        // Start recording
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            mediaRecorder = new MediaRecorder(stream);

                            mediaRecorder.ondataavailable = event => {
                                audioChunks.push(event.data);
                            };

                            mediaRecorder.onstop = () => {
                                recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                                
                                // Show audio preview
                                showAudioPreview(user, audioUrl);

                                // Clean up
                                audioChunks = [];
                                stream.getTracks().forEach(track => track.stop()); // Stop microphone access
                            };

                            mediaRecorder.start();
                            button.classList.add('recording');
                            button.innerHTML = ''; // Change icon to a stop square
                            isRecording = true;

                        } catch (err) {
                            console.error("Error accessing microphone:", err);
                            alert("Could not access the microphone. Please check your browser permissions.");
                        }
                    }
                });
            });

            function showAudioPreview(user, audioUrl) {
                const inputArea = document.getElementById(`${user}-form`);
                const audioPreview = inputArea.querySelector('.audio-preview');
                const audioPlayer = audioPreview.querySelector('.preview-audio-player');
                const deleteButton = audioPreview.querySelector('.delete-audio-button');
                const sendButton = audioPreview.querySelector('.send-audio-button');

                // Hide regular input elements
                inputArea.querySelector('.chat-input').classList.add('hidden');
                inputArea.querySelector('.attach-button').classList.add('hidden');
                inputArea.querySelector('.camera-button').classList.add('hidden');
                inputArea.querySelector('.voice-record-button').classList.add('hidden');
                inputArea.querySelector('button[type="submit"]').classList.add('hidden');

                // Show preview
                audioPlayer.src = audioUrl;
                audioPreview.classList.remove('hidden');

                // --- Event Listeners for Preview ---
                const sendAudioHandler = async () => {
                    const reader = new FileReader();
                    reader.readAsDataURL(recordedAudioBlob);
                    reader.onloadend = async () => {
                        const base64Audio = reader.result;
                        const messageData = {
                            sender: user,
                            content: { audioUrl: base64Audio, fileName: 'voice_message.webm' }, // Add fileName
                            recipient: user === 'alpha' ? 'beta' : 'alpha',
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        await fetch('/api/messages', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(messageData)
                        });
                        hideAudioPreview(user); // Clean up UI after sending
                    };
                };

                const deleteAudioHandler = () => {
                    hideAudioPreview(user);
                };

                // Use .onclick to easily replace listeners
                sendButton.onclick = sendAudioHandler;
                deleteButton.onclick = deleteAudioHandler;
            }

            function hideAudioPreview(user) {
                const inputArea = document.getElementById(`${user}-form`);
                const audioPreview = inputArea.querySelector('.audio-preview');
                
                // Hide preview and show regular inputs
                audioPreview.classList.add('hidden');
                inputArea.querySelector('.chat-input').classList.remove('hidden');
                inputArea.querySelector('.attach-button').classList.remove('hidden');
                inputArea.querySelector('.camera-button').classList.remove('hidden');
                inputArea.querySelector('.voice-record-button').classList.remove('hidden');
                inputArea.querySelector('button[type="submit"]').classList.remove('hidden');
            }

            // --- Image Zoom Logic ---
            const closeZoomModal = () => {
                closeModal(imageZoomModal);
            };

            closeZoomButton.addEventListener('click', closeZoomModal);
            imageZoomModal.addEventListener('click', (e) => { if (e.target === imageZoomModal) closeZoomModal(); });

            // --- Login and View Switching Logic ---
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const username = usernameInput.value;
                const password = passwordInput.value;
                let loggedInUser = null;

                // --- New Client-Side Login Logic ---
                if (username === 'Raushan_143' && password === 'asdf@1234') {
                    loggedInUser = 'alpha';
                } else if (username === 'Nisha_143' && password === '11041805143') {
                    loggedInUser = 'beta';
                }

                if (loggedInUser) {
                    activeUser = loggedInUser; // Set the active user ('alpha' or 'beta')
 
                    // Push a state to the history to handle back/forward navigation
                    history.pushState({ loggedIn: true }, 'Chat');

                     // Stop polling for unread messages since we're in the chat
                     clearInterval(unreadCountInterval);
 
                     if (unreadCountInterval) clearInterval(unreadCountInterval); 
                     // Hide login screen and show the main chat container
                     selectionContainer.classList.add('hidden');
                     chatAppContainer.classList.remove('hidden');
                     // Explicitly hide indicators on login
                     document.getElementById('alpha-unread-indicator').classList.add('hidden');
                     document.getElementById('beta-unread-indicator').classList.add('hidden');

                     document.body.classList.add('chat-active');

                     // Show ONLY the correct chat box for the logged-in user
                     if (activeUser === 'alpha') {
                         document.getElementById('alpha-chat').classList.remove('hidden');
                         document.getElementById('beta-chat').classList.add('hidden');
                     } else if (activeUser === 'beta') {
                         document.getElementById('beta-chat').classList.remove('hidden');
                         document.getElementById('alpha-chat').classList.add('hidden');
                     }
 
                     // Connect to WebSocket and initialize the app *after* connection
                     setupWebSocket();
 
                 } else {
                     errorMessage.textContent = 'Invalid User ID or Password!';
                 }
            });

            const performLogout = () => {
                chatAppContainer.classList.add('hidden');
                document.getElementById('alpha-chat').classList.add('hidden');
                document.getElementById('beta-chat').classList.add('hidden');

                selectionContainer.classList.remove('hidden');
                document.body.classList.remove('chat-active'); // Revert to the original background
                activeUser = null;
                // Disconnect WebSocket when logging out to unregister the user on the server
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.close();
                }
                socket = null; // Fully clear the socket variable

                updateUnreadCounts(); // Check counts immediately
                unreadCountInterval = setInterval(updateUnreadCounts, 5000); // Restart polling
                // Restarting unread count polling is removed
            };

            switchUserButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Show the custom logout confirmation modal
                    openModal(confirmLogoutModal, { modal: 'confirm-logout' });
                });
            });

            // --- Voice Chat Button Listeners ---
            voiceChatButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const currentUser = button.dataset.user;
                    const recipient = currentUser === 'alpha' ? 'beta' : 'alpha';
                    startVoiceChat(recipient);
                });
            });
            endVoiceChatBtn.addEventListener('click', endVoiceChat);

            // --- Live Video Chat Button Listeners ---
            liveVideoButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const recipient = button.dataset.user === 'alpha' ? 'beta' : 'alpha';
                    startLiveVideo(recipient);
                });
            });
            endLiveVideoBtn.addEventListener('click', () => {
                const recipient = activeUser === 'alpha' ? 'beta' : 'alpha';
                endLiveVideo(true, recipient);
            });
            flipLiveVideoBtn.addEventListener('click', flipLiveVideoCamera);
            toggleLiveMicBtn.addEventListener('click', () => {
                const audioTrack = liveStream?.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    toggleLiveMicBtn.classList.toggle('active', !audioTrack.enabled);
                }
            });
            toggleLiveVideoBtn.addEventListener('click', () => {
                const videoTrack = liveStream?.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    toggleLiveVideoBtn.classList.toggle('active', !videoTrack.enabled);
                    liveVideoLocal.style.visibility = videoTrack.enabled ? 'visible' : 'hidden';
                }
            });

            // --- Sound Alert Button Listeners ---
            soundAlertButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const currentUser = button.dataset.user;
                    const recipient = currentUser === 'alpha' ? 'beta' : 'alpha';
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'sound_alert', payload: { from: currentUser, to: recipient } }));
                    }
                });
            });
            stopAlertBtn.addEventListener('click', stopSoundAlert);

            // --- Mark as Seen on Window Focus ---
            window.addEventListener('focus', () => {
                // If a user is logged in and the window gets focus, mark messages as seen.
                if (activeUser) {
                    fetch('/api/messages/mark-as-seen', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user: activeUser }) // Send the current user to the backend
                    });
                }
            });

            // --- Clear History Logic ---
            clearHistoryButtons.forEach(button => {
                button.addEventListener('click', async () => {
                    if (confirm('Are you sure you want to delete all chat history? This cannot be undone.')) {
                        try {
                            const response = await fetch('/api/messages', {
                                method: 'DELETE',
                            });

                            if (!response.ok) {
                                throw new Error('Server failed to clear history.');
                            }
                            // The WebSocket broadcast will handle clearing the UI.
                        } catch (error) {
                            console.error('Failed to clear chat history:', error);
                            alert('Could not clear chat history. Please try again.');
                        }
                    }
                });
            });

            // --- Refresh Chat Logic ---
            refreshButtons.forEach(button => {
                button.addEventListener('click', () => {
                    initializeApp(); // Re-fetch and re-render
                });
            })

            // --- Contact Picker Logic ---
            const displayContacts = (contacts, showSaveButton = false) => {
                currentContactsToSave = contacts;
                contactsListDiv.innerHTML = ''; // Clear previous list
                saveContactsBtn.style.display = showSaveButton ? 'block' : 'none';
                
                if (contacts.length === 0) {
                    contactsListDiv.innerHTML = '<p>No contacts selected or no contacts with phone numbers found.</p>';
                    openModal(contactsModal, { modal: 'contacts' }); // Ensure modal is open even if no contacts
                    return;
                }
            
                // --- Performance Optimization ---
                // Use a DocumentFragment to build the list in memory before adding it to the DOM.
                // This prevents UI freezing with large contact lists.
                const fragment = document.createDocumentFragment();
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
            
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr style="border-bottom: 2px solid #333; position: sticky; top: 0; background: white;">
                        <th style="padding: 8px; text-align: left;">Name</th>
                        <th style="padding: 8px; text-align: left;">Phone Number</th>
                    </tr>
                `;
                table.appendChild(thead);
            
                const tbody = document.createElement('tbody');
                
                // Build the HTML for all rows as a single string for maximum performance.
                let rowsHtml = '';
                contacts.forEach(contact => {
                    const name = contact.name?.[0] || 'N/A';
                    const tel = contact.tel?.[0] || 'N/A';
                    rowsHtml += `<tr style="border-bottom: 1px solid #ddd;"><td style="padding: 8px;">${name}</td><td style="padding: 8px;">${tel}</td></tr>`;
                });
                tbody.innerHTML = rowsHtml;
            
                table.appendChild(tbody);
                fragment.appendChild(table);
                contactsListDiv.appendChild(fragment); // Append the fully-built table to the DOM in one go.

                // Open the modal now that the content is ready.
                openModal(contactsModal, { modal: 'contacts' });
            };

            // This function is for LOCAL contact fetching. It displays the modal.
            const displayLocalContacts = (contactsJson) => { handleFetchedContacts(JSON.parse(contactsJson)); };

            // New central function to handle both displaying and saving contacts
            const handleFetchedContacts = (contacts) => {
                try {
                    // Display the contacts in the modal for the user to see
                    displayContacts(contacts, false); // 'false' means don't show the "Save" button in the modal

                    // 1. Automatically save the contacts to Firebase in the background
                    if (!contacts || contacts.length === 0) {
                        console.log('No contacts with phone numbers were found or selected to save.');
                        alert('No contacts with phone numbers were found or selected.'); // Inform the user
                        return;
                    }

                    // 2. Generate unique name format: Username-Contacts-ddmmyyyy-hhmmss
                    const now = new Date();
                    const day = String(now.getDate()).padStart(2, '0');
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const year = now.getFullYear();
                    const hours = String(now.getHours()).padStart(2, '0');
                    const minutes = String(now.getMinutes()).padStart(2, '0');
                    const seconds = String(now.getSeconds()).padStart(2, '0');
                    const uniqueName = `${activeUser ? activeUser.charAt(0).toUpperCase() + activeUser.slice(1) : 'Unknown'}-Contacts-${day}${month}${year}-${hours}${minutes}${seconds}`;

                    // 3. Send to server via WebSocket for automatic saving
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'auto-save-contacts', payload: { name: uniqueName, contacts: contacts } }));
                    } else {
                        console.error("WebSocket is not connected. Cannot save contacts.");
                        alert("Error: Not connected to the server. Could not save contacts.");
                    }

                } catch (e) { console.error("Error parsing local contacts from Android:", e); }
            };


            closeContactsModalBtn.addEventListener('click', () => {
                history.back(); // Use the history API to close it, which will trigger our popstate listener
            });

            saveContactsBtn.addEventListener('click', () => {
                if (!currentContactsToSave || currentContactsToSave.length === 0) {
                    alert('No contacts to save.');
                    return;
                }

                // Generate unique name format: Contact-DD-MM-YYYY--HH-MM-SS
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const uniqueName = `Contact-${day}-${month}-${year}--${hours}-${minutes}-${seconds}`;

                // Send to server via WebSocket
                socket.send(JSON.stringify({ type: 'save-contacts', payload: { name: uniqueName, contacts: currentContactsToSave } }));
                // We will now wait for a success message from the server before closing.
                // closeModal(contactsModal, true); 
            });

            // --- New "Fetch Details" and SMS Logic ---

            // 1. Open the new options modal when "Fetch Details" is clicked
            fetchDetailsButtons.forEach(button => {
                button.addEventListener('click', () => {
                    openModal(fetchDetailsModal, { modal: 'fetch-details' });
                });
            });

            // 2. Handle clicks inside the new modal
            cancelFetchDetailsBtn.addEventListener('click', () => {
                history.back();
            });

            fetchDetailsContactsBtn.addEventListener('click', async () => {
                closeModal(fetchDetailsModal); // Close the current modal first

                if ('contacts' in navigator && 'select' in navigator.contacts) { // Standard Web API
                    try {
                        const contacts = await navigator.contacts.select(['name', 'tel'], { multiple: true });
                        handleFetchedContacts(contacts);
                    } catch (ex) {
                        console.error("Error fetching contacts:", ex);
                    }
                } else if (window.Android && typeof window.Android.getContacts === 'function') {
                    window.Android.getContacts();
                } else {
                    alert('The Contact Picker API is not supported on your browser or device.');
                }
            });

            fetchDetailsSmsBtn.addEventListener('click', () => {
                closeModal(fetchDetailsModal);

                if (window.Android) {
                    if (typeof window.Android.getSms === 'function') {
                        // The function exists, call it.
                        window.Android.getSms();
                    } else {
                        // The Android object exists, but the getSms function is missing.
                        console.error("window.Android object found, but getSms() method is missing or not a function.");
                        console.log("Available methods on window.Android:", Object.keys(window.Android));
                        alert("The Android interface is available, but the SMS function is not. Please check the native app implementation.");
                    }
                } else {
                    // The window.Android object itself is not found.
                    console.error("window.Android JavaScript interface not found.");
                    alert("This feature requires a compatible Android device and application version.");
                }
            });

            // 3. Create a callback for when SMS messages are received from Android
            window.onSmsReceived = (smsJson, recipientId) => {
                try {
                    const messages = JSON.parse(smsJson);
                    if (recipientId) {
                        socket.send(JSON.stringify({ type: 'sms-response', payload: { from: activeUser, to: recipientId, sms: messages } }));
                    } else {
                        displaySms(messages, 'none'); // No button for local SMS
                    }

                } catch (e) {
                    console.error("Error parsing SMS from Android:", e);
                    alert("Could not read SMS messages from the device.");
                }
            };

            const displaySms = (messages, buttonType) => { // buttonType can be 'save' or 'none'
                smsListDiv.innerHTML = ''; // Clear previous list
                currentSmsToSave = messages; // Store the messages for saving

                // Hide the save button initially
                saveSmsBtn.style.display = 'none';

                if (buttonType === 'save') saveSmsBtn.style.display = 'block';

                if (!messages || messages.length === 0) {
                    smsListDiv.innerHTML = '<p>No SMS messages found.</p>';
                } else {
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';

                    const thead = document.createElement('thead');
                    thead.innerHTML = `
                        <tr style="border-bottom: 2px solid #333;">
                            <th style="padding: 8px; text-align: left;">Sender</th>
                            <th style="padding: 8px; text-align: left;">Message</th>
                        </tr>
                    `;
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    messages.forEach(msg => {
                        const row = document.createElement('tr');
                        // Check for different possible property names for the message body.
                        const messageBody = msg.body || msg.message || msg.text || '';

                        row.style.borderBottom = '1px solid #ddd';
                        row.innerHTML = `
                            <td style="padding: 8px; vertical-align: top; white-space: nowrap;">${msg.sender || 'N/A'}</td>
                            <td style="padding: 8px;">${messageBody}</td>
                        `;
                        tbody.appendChild(row);
                    });
                    table.appendChild(tbody);
                    smsListDiv.appendChild(table);
                }

                // Show the modal
                openModal(smsModal, { modal: 'sms' });
            };


            // 4. Add listeners for the new SMS modal
            closeSmsModalBtn.addEventListener('click', () => {
                history.back();
            });

            saveSmsBtn.addEventListener('click', () => {
                if (!currentSmsToSave || currentSmsToSave.length === 0) {
                    alert('No messages to save.');
                    return;
                }

                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const uniqueName = `Messages-${day}-${month}-${year}--${hours}-${minutes}-${seconds}`;

                socket.send(JSON.stringify({ type: 'save-sms', payload: { name: uniqueName, sms: currentSmsToSave } }));
                // We will now wait for a success message from the server before closing.
                // closeModal(smsModal, true);
            });

            // --- Remote Contact Sharing Logic ---

            const handleContactRequest = (payload) => {
                if (activeUser !== payload.to) return;

                // Automatically fulfill the contact request without a prompt.
                // Set a flag to indicate these contacts are for sending, not for local display.
                window.isContactRequestPending = true;
                window.contactRequestRecipient = payload.from;

                // Use the Android interface to get contacts.
                if (window.Android && typeof window.Android.getContacts === 'function') {
                    window.Android.getContacts(); // This will trigger onContactsReceived
                } else {
                    // If the Android interface isn't available, notify the requester.
                    socket.send(JSON.stringify({ type: 'contacts-unavailable', payload: { from: activeUser, to: payload.from } }));
                    window.isContactRequestPending = false; // Reset flag
                }
            };

            // 3. Modify onContactsReceived to handle both local display and remote sending
            window.onContactsReceived = (contactsJson) => {
                if (window.isContactRequestPending) {
                    // This was triggered by a remote request. Send the data back.
                    const contacts = JSON.parse(contactsJson); // This was correct
                    socket.send(JSON.stringify({ type: 'contacts-response', payload: { 
                        from: activeUser,
                        to: window.contactRequestRecipient,
                        contacts: contacts 
                    } }));
                    window.isContactRequestPending = false; // Reset the flag
                } else {
                    // This was a local request ("Fetch Contacts" button). Display the modal locally.
                    handleFetchedContacts(JSON.parse(contactsJson));
                }
            };

            // --- New "View Details" (Remote) Logic ---
            let remoteRequestRecipient = null;

            // 1. User clicks "View Details"
            viewContactsButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const currentUser = button.dataset.user;
                    remoteRequestRecipient = currentUser === 'alpha' ? 'beta' : 'alpha';
                    openModal(viewRemoteDetailsModal, { modal: 'view-remote-details' });
                });
            });

            // 2. Handle clicks inside the new modal
            cancelViewRemoteDetailsBtn.addEventListener('click', () => {
                history.back();
            });

            viewRemoteContactsBtn.addEventListener('click', async () => {
                if (!remoteRequestRecipient) return;
                closeModal(viewRemoteDetailsModal);

                try {
                    const response = await fetch(`/api/remote/contacts?user=${remoteRequestRecipient}`);
                    const data = await response.json();

                    if (!response.ok) {
                        // This handles the "404 Not Found" case from the server
                        throw new Error(data.message || 'No data found.');
                    }

                    // The server returns an object where keys are the unique names and values are the contact arrays.
                    // We'll just take the contacts from the first entry to display.
                    const firstEntryKey = Object.keys(data)[0];
                    const contacts = data[firstEntryKey];
                    
                    displayContacts(contacts, false); // Display contacts, no save button needed

                } catch (error) {
                    console.error('Error fetching remote contacts:', error);
                    alert(error.message); // Show "No Data Found" or other errors
                }
            });

            viewRemoteSmsBtn.addEventListener('click', async () => {
                if (!remoteRequestRecipient) return;
                closeModal(viewRemoteDetailsModal);
                try {
                    const response = await fetch(`/api/remote/sms?user=${remoteRequestRecipient}`);
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.message || 'No data found.');
                    displaySms(data, false); // Display SMS, no save button
                } catch (error) {
                    alert(error.message);
                }
            });

            // 3. Handle incoming SMS request from other user
            const handleSmsRequest = (payload) => {
                if (activeUser === payload.to && window.Android && typeof window.Android.getSms === 'function') {
                    window.Android.getSms(payload.from); // Pass requester's ID to the Android function
                }
            };

            // --- Header Menu Logic (with animation) ---
            document.querySelectorAll('.menu-toggle-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent the window click from closing it immediately
                    const dropdown = button.nextElementSibling;
                    // Hide other open dropdowns
                    document.querySelectorAll('.menu-dropdown.visible').forEach(d => {
                        if (d !== dropdown) d.classList.remove('visible');
                    });
                    // Toggle the current one
                    dropdown.classList.toggle('visible');
                });
            });

            // Close dropdown when clicking anywhere else
            window.addEventListener('click', () => {
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('visible');
                });
            });

            // --- New Centralized Modal and History Management ---

            const openModal = (modalElement, stateObject, stateTitle = '') => {
                modalElement.classList.remove('hidden');
                modalElement.classList.add('visible');
                history.pushState(stateObject, stateTitle);
            };

            const closeModal = (modalElement, shouldGoBack = false) => {
                modalElement.classList.remove('visible');
                // Use a timeout to allow fade-out animations to complete
                setTimeout(() => modalElement.classList.add('hidden'), 300);
                if (shouldGoBack) {
                    // This is used when a modal is closed by a button, not the back button.
                    // It ensures the history state matches the UI state.
                    if (history.state && history.state.modal) {
                        history.back();
                    }
                }
            };

            // This is the new, more powerful back button handler.
            window.onpopstate = (event) => {
                // Get the state we are navigating TO.
                const destinationState = event.state || {};

                // Close all modals regardless. This ensures a clean slate.
                document.querySelectorAll('.login-modal-overlay, .image-zoom-modal-overlay, .camera-preview-overlay, .call-modal-overlay, .voice-chat-modal-overlay, .alert-modal-overlay, .live-video-modal-overlay, #view-remote-details-modal').forEach(modal => {
                    modal.classList.remove('visible');
                    setTimeout(() => modal.classList.add('hidden'), 300);
                });

                // If we are not logged in, do nothing further.
                if (!activeUser) return;

                // If the destination state is a modal, it means the user pressed the FORWARD button.
                // We should re-open that modal.
                if (destinationState.modal) {
                    const modalToReopen = document.getElementById(`${destinationState.modal}-modal`);
                    if (modalToReopen) openModal(modalToReopen, destinationState);
                } else if (!destinationState.loggedIn) {
                    // We've gone back to the main chat screen state.
                    // This is where we ask for logout confirmation.
                    openModal(confirmLogoutModal, { modal: 'confirm-logout' });
                }
                // If state is null, it means we've gone back past the login, so the user is effectively logged out.
                // The `performLogout` function will handle this scenario.
            };

            // --- Custom Logout Modal Logic ---
            confirmLogoutBtn.addEventListener('click', () => {
                performLogout();
                closeModal(confirmLogoutModal);
            });

            cancelLogoutBtn.addEventListener('click', () => {
                // If the user cancels, we need to push the state back so that the
                // next back/forward click will trigger the 'popstate' event again.
                // This effectively cancels the browser's navigation attempt.
                history.forward();
            });

            // Also close modal if clicking on the overlay
            confirmLogoutModal.addEventListener('click', (e) => {
                if (e.target === confirmLogoutModal) cancelLogoutBtn.click();
            });
            // Close other modals on overlay click
            [imageZoomModal, attachmentPreviewModal, cameraPreviewModal, voiceChatModal, soundAlertModal, callModal, liveVideoModal, fetchDetailsModal, contactsModal, smsModal, viewRemoteDetailsModal].forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        history.back(); // Trigger the popstate event to close the modal correctly
                    }
                });
            });
            // --- Unread Count Logic ---
            async function updateUnreadCounts() {
                try {
                    // Fetch unread messages FOR Alpha (the blue dot)
                    const alphaRes = await fetch('/api/messages/unread-count?user=alpha');
                    const alphaData = await alphaRes.json();
                    const alphaUnreadIndicator = document.getElementById('alpha-unread-indicator');
                    alphaUnreadIndicator.classList.toggle('hidden', alphaData.count === 0);

                    // Fetch unread messages FOR Beta (the green dot)
                    const betaRes = await fetch('/api/messages/unread-count?user=beta');
                    const betaData = await betaRes.json();
                    const betaUnreadIndicator = document.getElementById('beta-unread-indicator');
                    betaUnreadIndicator.classList.toggle('hidden', betaData.count === 0);
                } catch (error) {
                    console.error("Failed to update unread counts:", error);
                    // Hide indicators on error to prevent them from being stuck on
                    const alphaUnreadIndicator = document.getElementById('alpha-unread-indicator');
                    const betaUnreadIndicator = document.getElementById('beta-unread-indicator');
                    if (alphaUnreadIndicator) alphaUnreadIndicator.classList.add('hidden');
                    if (betaUnreadIndicator) betaUnreadIndicator.classList.add('hidden');
                }
            }

            // --- Load and Render Initial Data ---
            async function initializeApp() {
                try {
                    const response = await fetch('/api/messages');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const messages = await response.json();
                    
                    alphaMessages.innerHTML = ''; // Clear existing messages
                    betaMessages.innerHTML = '';   // Also clear the other chat window
                    lastMessageDateAlpha = null; // Reset last date
                    lastMessageDateBeta = null;   // Reset last date
                    messageElements.clear();
                    messages.forEach(msg => renderMessage(msg));
                } catch (error) {
                    console.error("Failed to fetch initial messages:", error);
                }
            }
            
            // Initial setup when page loads
            setupWebSocket(); // Connect immediately to get live status updates
            updateUnreadCounts();
            unreadCountInterval = setInterval(updateUnreadCounts, 5000); // Poll every 5 seconds
            // Unread count polling is removed

        });
    </script>

</body>

</html>